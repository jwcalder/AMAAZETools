#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 29 15:30:23 2021

@author: rileywilde
"""
from c_code import svi_module
from c_code import svipca_module
import numpy as np
import scipy.sparse as sparse

from skimage import exposure
from plyfile import PlyData, PlyElement
from mayavi import mlab
import rofunctions as rofu


def face_normals(P,T,normalize=True):
    """Computes normal vectors to triangles (faces).
        Args:
            P: n*3 float array 
            T: m*3 int array 
            normalize: Whether or not to normalize to unit vectors. If False, then the magnitude of each vector is twice the area of the corresponding triangle. Default is True
        Returns:
            A Numpy array of size (num_tri,3) containing the face normal vectors.
    """

    P1 = P[T[:,0],:]
    P2 = P[T[:,1],:]
    P3 = P[T[:,2],:]

    N = np.cross(P2-P1,P3-P1)
    if normalize:
        N = (N.T/np.linalg.norm(N,axis=1)).T
    return N

def tri_vert_adj(P,T,normalize=False):
    
    num_verts = P.shape[0]
    num_tri = T.shape[0]
    ind = np.arange(num_tri)

    I = np.hstack((T[:,0],T[:,1],T[:,2]))
    J = np.hstack((ind,ind,ind))
    F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(num_verts,num_tri)).tocsr()

    if normalize:
        num_adj_tri = F@np.ones(num_tri)
        F = sparse.spdiags(1/num_adj_tri,0,num_verts,num_verts)@F

    return F

#Returns unit normal vectors to vertices (averaging adjacent faces and normalizing)
def vertex_normals(P,T):

    fn = face_normals(P,T)
    F = tri_vert_adj(P,T)
    vn = F@fn
    norms = np.linalg.norm(vn,axis=1)
    norms[norms==0] = 1

    return vn/norms[:,np.newaxis]


#Read PLY file
#plydata = PlyData.read('meshes/dragon.ply')  #High resolution
plydata = PlyData.read('meshes/dragon_d1.ply') #Medium resolution
#plydata = PlyData.read('meshes/dragon_d2.ply') #Low resolution

#Convert data formats
tri_data = plydata['face'].data['vertex_indices']
T = np.vstack(tri_data)
T = np.ascontiguousarray(T,dtype=np.int32)
x = plydata['vertex'].data['x']
y = plydata['vertex'].data['y']
z = plydata['vertex'].data['z']
P = np.vstack((x,y,z))
P = P.transpose()
P = np.ascontiguousarray(P,dtype=np.float64)
n = P.shape[0]  #Number of vertices
m = T.shape[0]  #Number of faces

r = [.5]


n = P.shape[0]  #Number of vertices
    
rlen = np.max(np.shape(r))
     
eps_svi = 1.0       #Integration error tolerance for svi
eps_pca = 1.0
prog = 1.0      #Show progress (1=yes, 0=no)
    
ID = np.full((n), True) #Bool indicating at which vertices to compute SVI 
        
Sout = np.zeros((n,rlen), dtype=np.float64) #Stores output SVI
K1 = np.zeros((n,rlen), dtype=np.float64)                              
K2 = np.zeros((n,rlen), dtype=np.float64)
V1 = np.zeros((n,3*rlen), dtype=np.float64)
V2 = np.zeros((n,3*rlen), dtype=np.float64)
V3 = np.zeros((n,3*rlen), dtype=np.float64)
    
Z1 = np.zeros((n,1), dtype=np.float64)
Z = np.zeros((n), dtype=np.float64)
S = np.zeros((n), dtype=np.float64)
M = np.zeros((9*n), dtype=np.float64) #Stores output PCA matrix
    
VN = vertex_normals(P,T)
Z3 = np.zeros((3), dtype=np.float64)
    
#indexing for output:
I = np.arange(0,n)
I = I[I]
    
for k in np.arange(0,rlen):
    svipca_module.svipca(P,T,ID,r[k],eps_svi,eps_pca,prog,S,M)
    Sout[:,k] = S
    
    l = np.arange(3*k,3*k+3)
        
    L1 = np.zeros((n), dtype=np.float64)
    L2 = np.zeros((n), dtype=np.float64)
    L3 = np.zeros((n), dtype=np.float64)
    
    for i in I:
        A = M[np.arange(9*i,9*(i+1))]
        D,V = np.linalg.eig([A[[0,1,2]],A[[3,4,5]],A[[6,7,8]]])

        a = VN[i,:]@V

        loc = np.where(np.abs(a)==max(np.abs(a)))
        
        if loc == 0:
            L1[i] = D[1]
            L2[i] = D[2]
            L3[i] = D[0]
            V1[i,l] = V[:,1]
            V2[i,l] = V[:,2]
            V3[i,l] = V[:,0]
        elif loc==1:
            L1[i] = D[0]
            L2[i] = D[2]
            L3[i] = D[1]
            V1[i,l] = V[:,0]
            V2[i,l] = V[:,1]
            V3[i,l] = V[:,2]
        else:
            L1[i] = D[0]
            L2[i] = D[1]
            L3[i] = D[2]
            V1[i,l] = V[:,0]
            V2[i,l] = V[:,1]
            V3[i,l] = V[:,2]
     
    Kdiff = (L1-L2)*24/(np.pi*r[k]**6);
    Ksum = 16*np.pi*(r[k]**3)/3 - 8*S/(np.pi*r[k]**4)
    k1t = (Kdiff + Ksum)/2;
    k2t = (Ksum - Kdiff)/2;
        
    #want to ensure k1>k2:
    J = np.double(k1t > k2t); #logical
    
    #the broadcasting here is super obnoxious:
    K1[:,k]= J*k1t + (1-J)*k2t #if k1 max, keep it as k1, else swap
    
    K2[:,k] = (1-J)*k1t + J*k2t 
    v1t = V1[:,l] 
    v2t = V2[:,l]
    V1[:,l] = J[:,None]*v1t + (1-J[:,None])*v2t #so V1 corresponds to K1
    V2[:,l] = (1-J[:,None])*v1t + J[:,None]*v2t
           
    #now for quality control: if volume is not defined:
        
    #note: the boradcasting operations can be improved here
    visnegative = S == -1;
    vvneg = np.matlib.repmat(np.double(visnegative[:,None]==0),1,3)
    K1[visnegative,k] = 0; 
    K2[visnegative,k] = 0;
    V1[:,l] = vvneg*V1[:,l]    
    V2[:,l] = vvneg*V2[:,l]
    V3[:,l] = vvneg*V3[:,l]
    
    vecneg = -np.double(np.sum(V3[:,l]*VN<0,1)<0)
    vecneg[vecneg==0]=1
    o = vecneg[:,None]*np.ones((n,3))
    V3[:,l] = o*V3[:,l];
    V2[:,l] = o*V2[:,l];
    V1[:,l] = o*V1[:,l];
          
    #implementing right hand rule:
    rhr = -2*(np.double(np.sum(V3[:,l]*np.cross(V1[:,l],V2[:,l]),1) < 0)-.5);
    rhr = np.matlib.repmat(rhr[:,None],1,3)
    V1[:,l] = rhr*V1[:,l]

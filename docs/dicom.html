<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>amaazetools.dicom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>amaazetools.dicom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#Utilities for processing dicom volumes
import pandas as pd, numpy as np
import matplotlib.pyplot as plt
import pydicom as dicom
import scipy.ndimage as ndimage
import scipy.stats as stats
from skimage import measure
from skimage.transform import rescale
import os, multiprocessing
import sys
from joblib import Parallel, delayed
from . import trimesh as tm

#Withiness is a measure of how well 1D data clusters into two groups
def withiness(x):
    &#34;&#34;&#34; Computes withiness (how well 1-D data clusters into two groups).

        Parameters
        ----------
        x : (n,1) float array
            A 1-D collection of data.
        
        Returns
        -------
        w : float
            The withiness of the data.
        m : float
            The point at which to split the data into 2 clusters.
    &#34;&#34;&#34;

    x = np.sort(x)
    sigma = np.std(x)
    n = x.shape[0]
    v = np.zeros(n-1,)
    for i in range(n-1):
        x1 = x[:(i+1)]
        x2 = x[(i+1):]
        m1 = np.mean(x1);
        m2 = np.mean(x2);
        v[i] = (np.sum((x1-m1)**2) + np.sum((x2-m2)**2))/(sigma**2*n);
    ind = np.argmin(v)
    m = x[ind]
    w = v[ind]
    return w,m


def read_dicom_list(files):
    &#34;&#34;&#34; Reads dicom images from a provided list files, stores in a volume I, and returns resolution dx and dz and a list of files; some may be ommitted if they are not dicom.

        Parameters
        ----------
        files : str list
            List of files to read from.
        
        Returns
        -------
        I : Volume of images.
        dx : Image resolution dimension.
        dz : Image resolution dimension.
        dicom_files : List of dicom files.
    &#34;&#34;&#34;

    num_slices = len(files)
    dicom_files = []
    i = 0
    for f in files:
        try:
            A = dicom.dcmread(f)
            dicom_files.append(f)
            if i == 0:
                s = A.pixel_array.shape
                I = np.zeros((num_slices, s[0], s[1]), dtype=int)
                dx = np.zeros((num_slices, 2))
                dz = np.zeros(num_slices)
            I[i, :, :] = A.pixel_array
            dx[i, :] = A.PixelSpacing
            dz[i] = A.SliceThickness
            i += 1
        except:
            print(f + &#39; is not a DICOM file.&#39;)

    if i == 0:
        print(&#39;No DICOM files found.&#39;)
        return (None, None, None, None)
    else:
        print(&#39;Found %d DICOM files.&#39; % i)
        return (I[:i, :, :], dx[:i, :], dz[:i], dicom_files)


def find_dicom_subdir(directory):
    &#34;&#34;&#34; Finds subdirectory with the most dicom files

        Parameters
        ----------
        directory : str
            Directory to search within.

        Returns
        -------
        dicom_dir : str
            Subdirectory with the most dicom files.
    &#34;&#34;&#34;

    dicom_dir = None
    num_dicom_files = 0
    for root, subdirs, files in os.walk(directory):
        num = len(files)
        if num &gt; num_dicom_files:
            num_dicom_files = num
            dicom_dir = root
    return dicom_dir


def read_dicom_dir(directory):
    &#34;&#34;&#34; Finds and reads dicom volume from directory; finds the subdirectory with the most dicom files and loads those into a volume.

        Parameters
        ----------
        directory : str
            Directory to read from.

        Returns
        -------
        I : Volume of images.
        dx : Image resolution dimension.
        dz : Image resolution dimension.
        dicom_files : List of dicom files.
    &#34;&#34;&#34;

    dicom_dir = find_dicom_subdir(directory)
    files = os.listdir(dicom_dir)
    files.sort()
    files = [os.path.join(dicom_dir, f) for f in files]
    return read_dicom_list(files)

def add_border(I):
    &#34;&#34;&#34; Adds border to a given image.
        
        Parameters
        ----------
        I : float array
            Image to add border to.

        Returns
        -------
        I : float array
            Image with border added.
    &#34;&#34;&#34;

    I[0,:]=1
    I[-1,:]=1
    I[:,0]=1
    I[:,-1]=1

    return I

def bone_overview(I,mask=False):
    &#34;&#34;&#34; Returns an overview of the scan from top and side.

        Parameters
        ----------
        I : float array
            Image of scan.
        mask : boolean, default is False
            If True, only work with positive values of I.
        
        Returns
        -------
        J : float array
            Overview of scan from top and side.
    &#34;&#34;&#34;
    
    m0 = I.shape[0]
    m1 = I.shape[1]
    m2 = I.shape[2]

    I0 = np.sum(I, axis=0)
    I1 = np.sum(I, axis=1)
    I2 = np.sum(I, axis=2)

    if mask:
        I0 = I0&gt;0
        I1 = I1&gt;0
        I2 = I2&gt;0
    else:
        I0 = I0 / np.max(I0)
        I1 = I1 / np.max(I1)
        I2 = I2 / np.max(I2)

    I0 = add_border(I0)
    I1 = add_border(I1)
    I2 = add_border(I2)

    J = np.zeros((max(m0,m1),2*m2+m1))
    J[:m1,:m2] = I0
    J[:m0,m2:2*m2] = I1
    J[:m0,2*m2:] = I2

    return J


def scan_overview(I,true_mean=False):
    &#34;&#34;&#34; Returns an overview of the scan from top and side.

        Parameters
        ----------
        I : float array
            Image of scan.
        true_mean : boolean, default is False
            If True, take mean instead.

        Returns
        -------
        An overview of scan from top and side.
    &#34;&#34;&#34;

    if true_mean:
        I1 = np.mean(I,axis=1)
        I2 = np.mean(I,axis=2)
    else:
        I1 = np.sum(I, axis=1)
        I2 = np.sum(I, axis=2)
        I1 = I1 / np.max(I1)
        I2 = I2 / np.max(I2)

    return np.hstack((I1, I2)).T

def trim(I, v, padding=20, erosion_width=5):
    &#34;&#34;&#34; Trim to v level with padding.

        Parameters
        ----------
        I : float array
            Image of scan.
        v : float
            Level to be trimmed to.
        padding : float, default is 20
        erosion_width : float, default is 5
    
        Returns
        -------
        I : float array
            Trimmed image.
    &#34;&#34;&#34;

    J = I &gt; v

    #Add extra to account for erosion
    #padding = padding + 4*erosion_width

    #kernel = np.ones((3,3), dtype=int)
    #erosion = cv2.erode(J.astype(float),kernel,iterations=erosion_width)
    #J = cv2.dilate(erosion,kernel,iterations=erosion_width)

    K = np.sum(np.sum(J,axis=2),axis=1) &gt; 0
    ind = np.arange(len(K))[K]
    z1 = max(ind.min()-padding,0)
    z2 = min(ind.max()+padding,I.shape[0])

    K = np.sum(np.sum(J,axis=0),axis=1) &gt; 0
    ind = np.arange(len(K))[K]
    x1 = max(ind.min()-padding,0)
    x2 = min(ind.max()+padding,I.shape[1])

    K = np.sum(np.sum(J,axis=0),axis=0) &gt; 0
    ind = np.arange(len(K))[K]
    y1 = max(ind.min()-padding,0)
    y2 = min(ind.max()+padding,I.shape[2])

    return I[z1:z2,x1:x2,y1:y2]


def chop_up_scan(I, num_bones=5):
    &#34;&#34;&#34; Chop up a scan into num_bones fragments.
        
        Parameters
        ----------
        I : float array
            Image of scan.
        num_bones : int, default is 5
            Number of fragments to be chopped into.

        Returns
        -------
        The image of the bone split into fragments.
    &#34;&#34;&#34;

    #Project to 1D
    J = np.sum(I, axis=2)
    J = np.sum(J, axis=1)
    J = J / J.max()

    #Gaussian filtering
    sigma = len(J) / (num_bones * 8)
    K = ndimage.gaussian_filter1d(J, sigma)

    #Compute locations of maxima and minima
    Km = K[1:-1]
    minima = np.arange(len(J) - 2)[((Km &lt; K[2:]) &amp; (Km &lt; K[:-2]))]
    maxima = np.arange(len(J) - 2)[((Km &gt; K[2:]) &amp; (Km &gt; K[:-2]))]
    m1 = maxima.min()
    m2 = maxima.max()

    #Get chop locations
    chop_loc = minima[((minima &gt; m1) &amp; (minima &lt; m2))]

    #Some sanity checking
    if len(chop_loc) &gt;= num_bones:
        vals = Km[chop_loc]
        sort = np.sort(vals)
        cutoff = sort[(num_bones - 1)]
        chop_loc = chop_loc[(vals &lt; cutoff)]

    if len(chop_loc) &lt; num_bones - 1:
        print(&#39;Warning: Did not find enough bones when chopping up!&#39;)

    #Adjust the final positions with a finer Gaussian fileter
    sigma = len(J) / (num_bones * 16)
    K = ndimage.gaussian_filter1d(J, sigma)
    Km = K[1:-1]
    minima = np.arange(len(J) - 2)[((Km &lt; K[2:]) &amp; (Km &lt; K[:-2]))]
    for i in range(len(chop_loc)):
        chop_loc[i] = int((chop_loc[i] + minima[np.argmin(np.absolute(minima - chop_loc[i]))]) / 2)
    
    return chop_loc + 1


def imshow(J):
    &#34;&#34;&#34; Make showing grayscale images easier.

        Parameters
        ----------
        J : float array
            Image to show.

        Returns
        -------
        None
    &#34;&#34;&#34;

    plt.figure()
    plt.imshow(J, cmap=&#39;gray&#39;)

def surface_bones(directory, iso=2500, write_gif=False):
    &#34;&#34;&#34; Processes all npz files in directory creating surface and saving to a ply file.

        Parameters
        ----------
        directory : str
            Directory to work within.
        iso : float (optional), default is 2500
            Iso level to be used for surfacing.
        write_gif : bool (optional), default=False
            Whether to output rotating gifs for each object. Requires mayavi, which can be hard to install.

        Returns
        -------
        None
    &#34;&#34;&#34;

    for filename in os.listdir(directory):
        if filename.endswith(&#34;.npz&#34;):
            print(&#39;Loading &#39;+filename+&#39;...&#39;)
            M = np.load(os.path.join(directory,filename))
            I = M[&#39;I&#39;]; dx = M[&#39;dx&#39;]; dz = M[&#39;dz&#39;]

            #Rescale image to account for different dx/dz dimensions
            J = rescale(I.astype(float),(dz/dx,1,1),mode=&#39;constant&#39;)

            #Marching cubes for isosurface
            iso_level = iso
            verts,faces,normals,values = measure.marching_cubes(J,iso_level)
            mesh = tm.mesh(dx*verts,faces) #Multiplication by dx fixes units

            #Reverse orientation of triangles (marching_cubes returns inward normals)
            mesh.flip_normals()

            #Write to ply file
            mesh_filename = os.path.join(directory,filename[:-4]+&#39;_iso%d&#39;%iso_level)
            print(&#39;Saving mesh to &#39;+mesh_filename+&#39;...&#39;)
            mesh.to_ply(mesh_filename+&#39;.ply&#39;)

            if write_gif:
                mesh.to_gif(mesh_filename+&#39;.gif&#39;)


def process_dicom(directory, scanlayout, CTdir=&#39;ScanOverviews&#39;, Meshdir=&#39;Meshes&#39;, 
                             chopsheet=None, threshold=2000, padding=15):
    &#34;&#34;&#34; Processes all dicom scans from scanlayout in a given directory, producing
        CT volumes for each object. 

        Parameters
        ----------
        directory : str
            Directory to be working within.
        scanlayout : pandas DataFrame
            1st column is CT scan data, 2nd column is ScanPacket, 
            listing the subdirectories for each scan, third column 
            indicating L2R or R2L, and the next columns indicating 
            the specimens in that scan
        CTdir : str, default is &#39;ScanOverviews&#39;
            The directory to save all results. 
        Meshdir : str, default is &#39;Meshes&#39;
            The directory to save individual bone fragments
        chopsheet : default is None
            Gives the option for the user to adjust the automatic chopping of bones.
        threshold : float, default is 2000
            Threshold to use with CT_side_seg function.
        padding : float, default is 15
            Padding to use when drawing bounding boxes.

        Returns
        -------
        df : pandas DataFrame
            Chopsheet recording locations where objects were cropped. Returned only if chopsheet=None.
   &#34;&#34;&#34;

    #Number of bones in each scan
    num_bones = scanlayout.count(axis=1) - 4

    #Number of scans
    num_scans = len(scanlayout)

    #Make CTdir if it doesn&#39;t exist
    if not os.path.isdir(CTdir):
        os.mkdir(CTdir)

    #Make Meshdir if it doesn&#39;t exist
    if not os.path.isdir(Meshdir):
        os.mkdir(Meshdir)
 
    #Dataframe to hold chopsheet
    if chopsheet is None:
        df = pd.DataFrame(columns=[&#39;ScanPacket&#39;,&#39;Process&#39;,&#39;x1&#39;,&#39;x2&#39;,&#39;y1&#39;,&#39;y2&#39;,&#39;z1&#39;,&#39;z2&#39;])

    #Loop over all scans
    for i in range(num_scans):

        #Check if we should process this scan or not
        if (chopsheet is None) or chopsheet[&#39;Process&#39;][i]:

            #Get packet name
            subdir = scanlayout[&#39;ScanPacket&#39;][i]
            if not isinstance(subdir, str):
                subdir = str(subdir)
            d = os.path.join(directory, subdir)
            print(&#39;\nLoading scan &#39; + d + &#39;...&#39;)
            
            #Get bone names
            bone_names = scanlayout.iloc[i, 4:4+num_bones[i]].values.tolist()
            if scanlayout[&#39;CTHead2Tail&#39;][i] ==&#39;R2L&#39;:
                print(&#39;Reversed&#39;)
                bone_names.reverse()

            #Read CT volume
            I, dx, dz, dicom_files = read_dicom_dir(d)

            #Process resolutions and check that they are all the same
            if np.sum(dx[:,0]!=dx[:,1]):
                sys.exit(&#39;Error: x,y resolutions are different!!&#39;)
            dx = dx[:,0]

            dx_mode = stats.mode(dx).mode.flatten()[0]
            dz_mode = stats.mode(dz).mode.flatten()[0]

            ind = (dx != dx_mode) | (dz != dz_mode)
            num_diff = np.sum(ind)
            if num_diff:
                print(&#39;Found %d DICOM images with different resolution, removing those...&#39;%num_diff)
                I = I[~ind,:,:]
            dx = dx_mode
            dz = dz_mode

            if I is not None:

                if chopsheet is None: #Then chop and save to spreadsheet

                    K1 = CT_side_seg(I,num_bones[i],threshold=threshold,axis=1)    
                    K2 = CT_side_seg(I,num_bones[i],threshold=threshold,axis=2)    
                    x1,x2,y1,y2,z1,z2 = bone_bounding_boxes(K1,K2)

                    str_x1 = np.array2string(x1, separator=&#39;,&#39;)
                    str_x2 = np.array2string(x2, separator=&#39;,&#39;)
                    str_y1 = np.array2string(y1, separator=&#39;,&#39;)
                    str_y2 = np.array2string(y2, separator=&#39;,&#39;)
                    str_z1 = np.array2string(z1, separator=&#39;,&#39;)
                    str_z2 = np.array2string(z2, separator=&#39;,&#39;)

                    df = df.append({&#39;ScanPacket&#39;:subdir, &#39;Process&#39;:True, &#39;x1&#39;:str_x1, &#39;x2&#39;:str_x2, 
                                                                         &#39;y1&#39;:str_y1, &#39;y2&#39;:str_y2, 
                                                                         &#39;z1&#39;:str_z1, &#39;z2&#39;:str_z2,}, ignore_index=True)
                else: #Load chop locations from spreadsheet

                    x1 = np.fromstring(chopsheet[&#39;x1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    x2 = np.fromstring(chopsheet[&#39;x2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    y1 = np.fromstring(chopsheet[&#39;y1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    y2 = np.fromstring(chopsheet[&#39;y2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    z1 = np.fromstring(chopsheet[&#39;z1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    z2 = np.fromstring(chopsheet[&#39;z2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)

                J = draw_bounding_boxes(I,x1,x2,y1,y2,z1,z2,padding=padding)
                plt.imsave(os.path.join(CTdir, subdir + &#39;.png&#39;), J, cmap=&#39;gray&#39;)

                #Chop, and create overview of CT image of bone
                for j in range(len(bone_names)):
                    bonename = bone_names[j] + &#39;_&#39; + scanlayout[&#39;CT&#39;][i]
                    print(&#39;Saving &#39;+bonename+&#39;...&#39;)

                    #Chop
                    Isub = crop_image(I,x1[j],x2[j],y1[j],y2[j],z1[j],z2[j],padding=padding)

                    #Correct for mirroring on some scans
                    if scanlayout[&#39;Mirrored&#39;][i] == &#39;yes&#39;:
                        print(&#39;Mirrored&#39;)
                        Isub = Isub[::-1,:,:]

                    #Create and save overview of bone
                    Jsub = bone_overview(Isub)
                    plt.imsave(os.path.join(Meshdir,bonename + &#39;.png&#39;), Jsub, cmap=&#39;gray&#39;)

                    #Save 3D bone volume
                    np.savez_compressed(os.path.join(Meshdir,bonename + &#39;.npz&#39;), I=Isub, dx=dx, dz=dz, bonename=bonename)

    if chopsheet is None:
        return df



#Segment bones on a side view of CT scanning bed 
def CT_side_seg(I,num_bones,threshold=3000,axis=1):
    &#34;&#34;&#34; Segments bones on a side view of the CT scanning bed.
    
        Parameters
        ----------
        I : float array
            Image of scan.
        num_bones : int
            Number of bones present.
        threshold : float, default is 3000
            Threshold value to use on I.
        axis : int, default is 1
            Axis on which to sum I.

        Returns 
        -------
        K : float array
            Segmented image.
    &#34;&#34;&#34;

    J = np.sum(I &gt; threshold,axis=axis).T &gt; 0
    J = J.astype(float)
    n = J.shape[0]; m = J.shape[1]
    labels = measure.label(J)

    #Restrict to the largest num_bones regions
    L = np.unique(labels)
    num = len(L)
    sizes = np.zeros(num)
    for i in range(num):
        sizes[i] = np.sum(labels==L[i])
    sort_ind = np.argsort(-sizes)[1:num_bones+1]
    L = L[sort_ind]

    #Sort the bones from left to right in the scanning bed
    pos = np.zeros(num_bones)
    X = np.ones((n,1))@np.reshape(np.arange(m),(1,m))
    for i in range(num_bones):
        pos[i] = np.mean(X[labels == L[i]])
    sort_ind = np.argsort(pos)
    L = L[sort_ind]
    
    #Format segmented image to return
    K = np.zeros_like(J)
    for i in range(num_bones):
        K[labels == L[i]] = i+1

    return K

#Finds bounding boxes for bones from CT_side_seg images
def bone_bounding_boxes(K1,K2):
    &#34;&#34;&#34; Finds the bounding boxes for the bones produced by CT_side_seg.

        Parameters
        ----------
        K1 : float array
            First axis of side segmentation.
        K2 : float array
            Second axis of side segmentation.

        Returns
        -------
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
    &#34;&#34;&#34;

    n = K1.shape[0]; m = K1.shape[1]
    num_bones = int(np.max(K1))

    X = np.ones((n,1))@np.reshape(np.arange(m),(1,m))
    Z = np.reshape(np.arange(n),(n,1))@np.ones((1,m))
    x1 = np.zeros(num_bones,dtype=int)
    x2 = np.zeros(num_bones,dtype=int)
    y1 = np.zeros(num_bones,dtype=int)
    y2 = np.zeros(num_bones,dtype=int)
    z1 = np.zeros(num_bones,dtype=int)
    z2 = np.zeros(num_bones,dtype=int)
    for i in range(num_bones):
        x1[i] = np.min(X[K1 == i+1])
        x2[i] = np.max(X[K1 == i+1])
        y1[i] = np.min(Z[K2 == i+1])
        y2[i] = np.max(Z[K2 == i+1])
        z1[i] = np.min(Z[K1 == i+1])
        z2[i] = np.max(Z[K1 == i+1])

    return x1,x2,y1,y2,z1,z2

#Crop with padding 
def crop_image(I,x1,x2,y1,y2,z1,z2,padding=15):
    &#34;&#34;&#34; Crop an image with padding.

        Parameters
        ----------
        I : float array
            Image of scan.
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
        padding : float, default is 15
            Padding to use around bounding boxes.

        Returns
        -------
        Cropped image.
    &#34;&#34;&#34;

    #Add padding to boxes
    x1 = max(x1 - padding,0)
    y1 = max(y1 - padding,0)
    z1 = max(z1 - padding,0)
    x2 = min(x2 + padding,I.shape[0]-1)
    y2 = min(y2 + padding,I.shape[1]-1)
    z2 = min(z2 + padding,I.shape[2]-1)

    return I[x1:x2,y1:y2,z1:z2]


#Draw bounding boxes on scan
def draw_bounding_boxes(I,x1,x2,y1,y2,z1,z2,padding=15):
    &#34;&#34;&#34; Draw bounding boxes on a scan.
    
        Parameters
        ----------
        I : float array
            Image of a scan.
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
        padding : float, default is 15
            Padding to use around bounding boxes.

        Returns
        -------
        Image with bounding boxes around it.
    &#34;&#34;&#34;

    num_bones = len(x1)

    #Create side views
    I1 = np.sum(I, axis=1)
    I2 = np.sum(I, axis=2)
    I1 = I1 / np.max(I1)
    I2 = I2 / np.max(I2)

    #Add padding to boxes
    x1 = np.maximum(x1 - padding,0)
    y1 = np.maximum(y1 - padding,0)
    z1 = np.maximum(z1 - padding,0)
    x2 = np.minimum(x2 + padding,I.shape[0]-1)
    y2 = np.minimum(y2 + padding,I.shape[1]-1)
    z2 = np.minimum(z2 + padding,I.shape[2]-1)

    #Draw boxes on I1
    for i in range(num_bones):
        I1[x1[i]:x2[i],z1[i]] = 1
        I1[x1[i]:x2[i],z2[i]] = 1
        I1[x1[i],z1[i]:z2[i]] = 1
        I1[x2[i],z1[i]:z2[i]] = 1

    #Draw boxes on I2
    for i in range(num_bones):
        I2[x1[i]:x2[i],y1[i]] = 1
        I2[x1[i]:x2[i],y2[i]] = 1
        I2[x1[i],y1[i]:y2[i]] = 1
        I2[x2[i],y1[i]:y2[i]] = 1

    return np.hstack((I1,I2)).T

def image_segmentation(I,lam=1,eps=0.5,min_iter=20,max_iter=200,stopping_crit=10,visualize=False):
    &#34;&#34;&#34; Segment a given image.

        Parameters
        ----------
        I : float array
            Image of a scan.
        lam : float, default is 1
            Used to calculate changes.
        eps : float, default is 0.5
            Used to calculate changes.
        min_iter : int, default is 20
            Minimum number of iterations on which to run.
        max_iter : int, default is 200
            Maximum number of iterations on which to run.
        stopping_crit : float, default is 10
            Used to stop before max iterations.
        visualize : boolean, default is False
            If True, plot results.

        Returns
        -------
        Positive values of u.
    &#34;&#34;&#34;

    n = I.shape[0]
    m = I.shape[1]
    
    Y,X = np.mgrid[:n,:m]
    u =  np.sin(20*X*np.pi/m)*np.sin(20*Y*np.pi/n)
    print(np.max(X))
    print(np.max(Y))

    num_changed = np.inf
    count = 0
    tin_old = np.inf

    #Set up indexing arrays
    Yp = np.arange(1,n+1); Yp[n-1]=n-2
    Ym = np.arange(-1,n-1); Ym[0]=1
    Xp = np.arange(1,m+1); Xp[m-1]=m-2
    Xm = np.arange(-1,m-1); Xm[0]=1

    if visualize:
        plt.imshow(I,cmap=&#39;gray&#39;)
        plt.axis(&#39;off&#39;)
        seg = plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))

    dt = np.pi*eps**2/4/lam
    while (count &lt; min_iter) or (num_changed &gt; stopping_crit and count &lt; max_iter):
        Rin = u&gt;0; Rout = u&lt;=0
        Iin = I[Rin]; Iout = I[Rout]
        tin = np.sum(Rin); tout= np.sum(Rout)

        cin = 0; cout =0
        if tin &gt; 0:
           cin = np.mean(Iin)
        if tout &gt; 0:
           cout = np.mean(Iout)
        num_changed = abs(tin - tin_old)
        tin_old = tin;

        #Compute gradient
        GE = u[Yp,:] - u 
        GW = u[Ym,:] - u
        GN = u[:,Xm] - u  
        GS = u[:,Xp] - u 

        delta = eps/(np.pi*(eps**2 + u**2))
        div = (GN/np.sqrt(eps**2 + GN**2) + GE/np.sqrt(eps**2 + GE**2) + GS/np.sqrt(eps**2 + GS**2) + GW/np.sqrt(eps**2 + GW**2))
        fid = (I - cout)**2 - (I - cin)**2

        u = u + dt*delta*(lam*div + fid)
    
        if visualize:
            seg.collections[0].remove()
            seg = plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))
            plt.pause(0.01)

        count = count+1;
        print(count)

    if cin &lt; cout:
        u = -u

    return u &gt; 0

def seg_plot(I,u):
    &#34;&#34;&#34; Plot the segmented image.

        Parameters
        ----------
        I : float array
            Image of a scan.
        u : boolean array
            The segmentation of that image.

        Returns
        -------
        None
    &#34;&#34;&#34;

    n = I.shape[0]
    m = I.shape[1]
    Y,X = np.mgrid[:n,:m]
    plt.imshow(I,cmap=&#39;gray&#39;)
    plt.axis(&#39;off&#39;)
    plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))

def seg_adjacency_matrix(u):

    n = I.shape[0]
    m = I.shape[1]

    Y,X = np.mgrid[:n,:m]
    X = X.flatten()
    Y = Y.flatten()
    u = u.flatten()

    C = np.ravel_multi_index((X,Y),(m,n),mode=&#39;clip&#39;)
    E = np.ravel_multi_index((X+1,Y),(m,n),mode=&#39;clip&#39;)
    W = np.ravel_multi_index((X-1,Y),(m,n),mode=&#39;clip&#39;)
    N = np.ravel_multi_index((X,Y-1),(m,n),mode=&#39;clip&#39;)
    S = np.ravel_multi_index((X,Y+1),(m,n),mode=&#39;clip&#39;)
    
    WE = u(C) == u(E)
    WW = u(C) == u(W)
    WS = u(C) == u(S)
    WN = u(C) == u(N)

    ME = sparse.coo_matrix((WE, (C,E)),shape=(n*m,n*m)).to_csr()
    MW = sparse.coo_matrix((WW, (C,W)),shape=(n*m,n*m)).to_csr()
    MS = sparse.coo_matrix((WS, (C,S)),shape=(n*m,n*m)).to_csr()
    MN = sparse.coo_matrix((WN, (C,N)),shape=(n*m,n*m)).to_csr()

    M = ME + MW + MS + MN
    M = M - sparse.spdiags(M.diagonal(),0,n*m,n*m)
    
    ind = u &gt; 0
    M = M[u&gt;0,:]
    M = M[:,u&gt;0]
    X = X[u&gt;0]
    Y = Y[u&gt;0]

    return M,X,Y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="amaazetools.dicom.CT_side_seg"><code class="name flex">
<span>def <span class="ident">CT_side_seg</span></span>(<span>I, num_bones, threshold=3000, axis=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Segments bones on a side view of the CT scanning bed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>num_bones</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bones present.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, default <code>is 3000</code></dt>
<dd>Threshold value to use on I.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, default <code>is 1</code></dt>
<dd>Axis on which to sum I.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>K : float array
Segmented image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CT_side_seg(I,num_bones,threshold=3000,axis=1):
    &#34;&#34;&#34; Segments bones on a side view of the CT scanning bed.
    
        Parameters
        ----------
        I : float array
            Image of scan.
        num_bones : int
            Number of bones present.
        threshold : float, default is 3000
            Threshold value to use on I.
        axis : int, default is 1
            Axis on which to sum I.

        Returns 
        -------
        K : float array
            Segmented image.
    &#34;&#34;&#34;

    J = np.sum(I &gt; threshold,axis=axis).T &gt; 0
    J = J.astype(float)
    n = J.shape[0]; m = J.shape[1]
    labels = measure.label(J)

    #Restrict to the largest num_bones regions
    L = np.unique(labels)
    num = len(L)
    sizes = np.zeros(num)
    for i in range(num):
        sizes[i] = np.sum(labels==L[i])
    sort_ind = np.argsort(-sizes)[1:num_bones+1]
    L = L[sort_ind]

    #Sort the bones from left to right in the scanning bed
    pos = np.zeros(num_bones)
    X = np.ones((n,1))@np.reshape(np.arange(m),(1,m))
    for i in range(num_bones):
        pos[i] = np.mean(X[labels == L[i]])
    sort_ind = np.argsort(pos)
    L = L[sort_ind]
    
    #Format segmented image to return
    K = np.zeros_like(J)
    for i in range(num_bones):
        K[labels == L[i]] = i+1

    return K</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.add_border"><code class="name flex">
<span>def <span class="ident">add_border</span></span>(<span>I)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds border to a given image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image to add border to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image with border added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_border(I):
    &#34;&#34;&#34; Adds border to a given image.
        
        Parameters
        ----------
        I : float array
            Image to add border to.

        Returns
        -------
        I : float array
            Image with border added.
    &#34;&#34;&#34;

    I[0,:]=1
    I[-1,:]=1
    I[:,0]=1
    I[:,-1]=1

    return I</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.bone_bounding_boxes"><code class="name flex">
<span>def <span class="ident">bone_bounding_boxes</span></span>(<span>K1, K2)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the bounding boxes for the bones produced by CT_side_seg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>K1</code></strong> :&ensp;<code>float array</code></dt>
<dd>First axis of side segmentation.</dd>
<dt><strong><code>K2</code></strong> :&ensp;<code>float array</code></dt>
<dd>Second axis of side segmentation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min x dimension for each fragment.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max x dimension for each fragment.</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min y dimension for each fragment.</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max y dimension for each fragment.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min z dimension for each fragment.</dd>
<dt><strong><code>z2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max z dimension for each fragment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bone_bounding_boxes(K1,K2):
    &#34;&#34;&#34; Finds the bounding boxes for the bones produced by CT_side_seg.

        Parameters
        ----------
        K1 : float array
            First axis of side segmentation.
        K2 : float array
            Second axis of side segmentation.

        Returns
        -------
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
    &#34;&#34;&#34;

    n = K1.shape[0]; m = K1.shape[1]
    num_bones = int(np.max(K1))

    X = np.ones((n,1))@np.reshape(np.arange(m),(1,m))
    Z = np.reshape(np.arange(n),(n,1))@np.ones((1,m))
    x1 = np.zeros(num_bones,dtype=int)
    x2 = np.zeros(num_bones,dtype=int)
    y1 = np.zeros(num_bones,dtype=int)
    y2 = np.zeros(num_bones,dtype=int)
    z1 = np.zeros(num_bones,dtype=int)
    z2 = np.zeros(num_bones,dtype=int)
    for i in range(num_bones):
        x1[i] = np.min(X[K1 == i+1])
        x2[i] = np.max(X[K1 == i+1])
        y1[i] = np.min(Z[K2 == i+1])
        y2[i] = np.max(Z[K2 == i+1])
        z1[i] = np.min(Z[K1 == i+1])
        z2[i] = np.max(Z[K1 == i+1])

    return x1,x2,y1,y2,z1,z2</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.bone_overview"><code class="name flex">
<span>def <span class="ident">bone_overview</span></span>(<span>I, mask=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an overview of the scan from top and side.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, only work with positive values of I.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>J</code></strong> :&ensp;<code>float array</code></dt>
<dd>Overview of scan from top and side.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bone_overview(I,mask=False):
    &#34;&#34;&#34; Returns an overview of the scan from top and side.

        Parameters
        ----------
        I : float array
            Image of scan.
        mask : boolean, default is False
            If True, only work with positive values of I.
        
        Returns
        -------
        J : float array
            Overview of scan from top and side.
    &#34;&#34;&#34;
    
    m0 = I.shape[0]
    m1 = I.shape[1]
    m2 = I.shape[2]

    I0 = np.sum(I, axis=0)
    I1 = np.sum(I, axis=1)
    I2 = np.sum(I, axis=2)

    if mask:
        I0 = I0&gt;0
        I1 = I1&gt;0
        I2 = I2&gt;0
    else:
        I0 = I0 / np.max(I0)
        I1 = I1 / np.max(I1)
        I2 = I2 / np.max(I2)

    I0 = add_border(I0)
    I1 = add_border(I1)
    I2 = add_border(I2)

    J = np.zeros((max(m0,m1),2*m2+m1))
    J[:m1,:m2] = I0
    J[:m0,m2:2*m2] = I1
    J[:m0,2*m2:] = I2

    return J</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.chop_up_scan"><code class="name flex">
<span>def <span class="ident">chop_up_scan</span></span>(<span>I, num_bones=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Chop up a scan into num_bones fragments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>num_bones</code></strong> :&ensp;<code>int</code>, default <code>is 5</code></dt>
<dd>Number of fragments to be chopped into.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The image of the bone split into fragments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chop_up_scan(I, num_bones=5):
    &#34;&#34;&#34; Chop up a scan into num_bones fragments.
        
        Parameters
        ----------
        I : float array
            Image of scan.
        num_bones : int, default is 5
            Number of fragments to be chopped into.

        Returns
        -------
        The image of the bone split into fragments.
    &#34;&#34;&#34;

    #Project to 1D
    J = np.sum(I, axis=2)
    J = np.sum(J, axis=1)
    J = J / J.max()

    #Gaussian filtering
    sigma = len(J) / (num_bones * 8)
    K = ndimage.gaussian_filter1d(J, sigma)

    #Compute locations of maxima and minima
    Km = K[1:-1]
    minima = np.arange(len(J) - 2)[((Km &lt; K[2:]) &amp; (Km &lt; K[:-2]))]
    maxima = np.arange(len(J) - 2)[((Km &gt; K[2:]) &amp; (Km &gt; K[:-2]))]
    m1 = maxima.min()
    m2 = maxima.max()

    #Get chop locations
    chop_loc = minima[((minima &gt; m1) &amp; (minima &lt; m2))]

    #Some sanity checking
    if len(chop_loc) &gt;= num_bones:
        vals = Km[chop_loc]
        sort = np.sort(vals)
        cutoff = sort[(num_bones - 1)]
        chop_loc = chop_loc[(vals &lt; cutoff)]

    if len(chop_loc) &lt; num_bones - 1:
        print(&#39;Warning: Did not find enough bones when chopping up!&#39;)

    #Adjust the final positions with a finer Gaussian fileter
    sigma = len(J) / (num_bones * 16)
    K = ndimage.gaussian_filter1d(J, sigma)
    Km = K[1:-1]
    minima = np.arange(len(J) - 2)[((Km &lt; K[2:]) &amp; (Km &lt; K[:-2]))]
    for i in range(len(chop_loc)):
        chop_loc[i] = int((chop_loc[i] + minima[np.argmin(np.absolute(minima - chop_loc[i]))]) / 2)
    
    return chop_loc + 1</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.crop_image"><code class="name flex">
<span>def <span class="ident">crop_image</span></span>(<span>I, x1, x2, y1, y2, z1, z2, padding=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop an image with padding.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min x dimension for each fragment.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max x dimension for each fragment.</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min y dimension for each fragment.</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max y dimension for each fragment.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min z dimension for each fragment.</dd>
<dt><strong><code>z2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max z dimension for each fragment.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, default <code>is 15</code></dt>
<dd>Padding to use around bounding boxes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Cropped image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_image(I,x1,x2,y1,y2,z1,z2,padding=15):
    &#34;&#34;&#34; Crop an image with padding.

        Parameters
        ----------
        I : float array
            Image of scan.
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
        padding : float, default is 15
            Padding to use around bounding boxes.

        Returns
        -------
        Cropped image.
    &#34;&#34;&#34;

    #Add padding to boxes
    x1 = max(x1 - padding,0)
    y1 = max(y1 - padding,0)
    z1 = max(z1 - padding,0)
    x2 = min(x2 + padding,I.shape[0]-1)
    y2 = min(y2 + padding,I.shape[1]-1)
    z2 = min(z2 + padding,I.shape[2]-1)

    return I[x1:x2,y1:y2,z1:z2]</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.draw_bounding_boxes"><code class="name flex">
<span>def <span class="ident">draw_bounding_boxes</span></span>(<span>I, x1, x2, y1, y2, z1, z2, padding=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw bounding boxes on a scan.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of a scan.</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min x dimension for each fragment.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max x dimension for each fragment.</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min y dimension for each fragment.</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max y dimension for each fragment.</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Min z dimension for each fragment.</dd>
<dt><strong><code>z2</code></strong> :&ensp;<code>(num_bones,1) float array</code></dt>
<dd>Max z dimension for each fragment.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, default <code>is 15</code></dt>
<dd>Padding to use around bounding boxes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Image with bounding boxes around it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_bounding_boxes(I,x1,x2,y1,y2,z1,z2,padding=15):
    &#34;&#34;&#34; Draw bounding boxes on a scan.
    
        Parameters
        ----------
        I : float array
            Image of a scan.
        x1 : (num_bones,1) float array
            Min x dimension for each fragment.
        x2 : (num_bones,1) float array
            Max x dimension for each fragment.
        y1 : (num_bones,1) float array
            Min y dimension for each fragment.
        y2 : (num_bones,1) float array
            Max y dimension for each fragment.
        z1 : (num_bones,1) float array
            Min z dimension for each fragment.
        z2 : (num_bones,1) float array
            Max z dimension for each fragment.
        padding : float, default is 15
            Padding to use around bounding boxes.

        Returns
        -------
        Image with bounding boxes around it.
    &#34;&#34;&#34;

    num_bones = len(x1)

    #Create side views
    I1 = np.sum(I, axis=1)
    I2 = np.sum(I, axis=2)
    I1 = I1 / np.max(I1)
    I2 = I2 / np.max(I2)

    #Add padding to boxes
    x1 = np.maximum(x1 - padding,0)
    y1 = np.maximum(y1 - padding,0)
    z1 = np.maximum(z1 - padding,0)
    x2 = np.minimum(x2 + padding,I.shape[0]-1)
    y2 = np.minimum(y2 + padding,I.shape[1]-1)
    z2 = np.minimum(z2 + padding,I.shape[2]-1)

    #Draw boxes on I1
    for i in range(num_bones):
        I1[x1[i]:x2[i],z1[i]] = 1
        I1[x1[i]:x2[i],z2[i]] = 1
        I1[x1[i],z1[i]:z2[i]] = 1
        I1[x2[i],z1[i]:z2[i]] = 1

    #Draw boxes on I2
    for i in range(num_bones):
        I2[x1[i]:x2[i],y1[i]] = 1
        I2[x1[i]:x2[i],y2[i]] = 1
        I2[x1[i],y1[i]:y2[i]] = 1
        I2[x2[i],y1[i]:y2[i]] = 1

    return np.hstack((I1,I2)).T</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.find_dicom_subdir"><code class="name flex">
<span>def <span class="ident">find_dicom_subdir</span></span>(<span>directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds subdirectory with the most dicom files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to search within.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dicom_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>Subdirectory with the most dicom files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_dicom_subdir(directory):
    &#34;&#34;&#34; Finds subdirectory with the most dicom files

        Parameters
        ----------
        directory : str
            Directory to search within.

        Returns
        -------
        dicom_dir : str
            Subdirectory with the most dicom files.
    &#34;&#34;&#34;

    dicom_dir = None
    num_dicom_files = 0
    for root, subdirs, files in os.walk(directory):
        num = len(files)
        if num &gt; num_dicom_files:
            num_dicom_files = num
            dicom_dir = root
    return dicom_dir</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.image_segmentation"><code class="name flex">
<span>def <span class="ident">image_segmentation</span></span>(<span>I, lam=1, eps=0.5, min_iter=20, max_iter=200, stopping_crit=10, visualize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Segment a given image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of a scan.</dd>
<dt><strong><code>lam</code></strong> :&ensp;<code>float</code>, default <code>is 1</code></dt>
<dd>Used to calculate changes.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, default <code>is 0.5</code></dt>
<dd>Used to calculate changes.</dd>
<dt><strong><code>min_iter</code></strong> :&ensp;<code>int</code>, default <code>is 20</code></dt>
<dd>Minimum number of iterations on which to run.</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code>, default <code>is 200</code></dt>
<dd>Maximum number of iterations on which to run.</dd>
<dt><strong><code>stopping_crit</code></strong> :&ensp;<code>float</code>, default <code>is 10</code></dt>
<dd>Used to stop before max iterations.</dd>
<dt><strong><code>visualize</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, plot results.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Positive values of u.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_segmentation(I,lam=1,eps=0.5,min_iter=20,max_iter=200,stopping_crit=10,visualize=False):
    &#34;&#34;&#34; Segment a given image.

        Parameters
        ----------
        I : float array
            Image of a scan.
        lam : float, default is 1
            Used to calculate changes.
        eps : float, default is 0.5
            Used to calculate changes.
        min_iter : int, default is 20
            Minimum number of iterations on which to run.
        max_iter : int, default is 200
            Maximum number of iterations on which to run.
        stopping_crit : float, default is 10
            Used to stop before max iterations.
        visualize : boolean, default is False
            If True, plot results.

        Returns
        -------
        Positive values of u.
    &#34;&#34;&#34;

    n = I.shape[0]
    m = I.shape[1]
    
    Y,X = np.mgrid[:n,:m]
    u =  np.sin(20*X*np.pi/m)*np.sin(20*Y*np.pi/n)
    print(np.max(X))
    print(np.max(Y))

    num_changed = np.inf
    count = 0
    tin_old = np.inf

    #Set up indexing arrays
    Yp = np.arange(1,n+1); Yp[n-1]=n-2
    Ym = np.arange(-1,n-1); Ym[0]=1
    Xp = np.arange(1,m+1); Xp[m-1]=m-2
    Xm = np.arange(-1,m-1); Xm[0]=1

    if visualize:
        plt.imshow(I,cmap=&#39;gray&#39;)
        plt.axis(&#39;off&#39;)
        seg = plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))

    dt = np.pi*eps**2/4/lam
    while (count &lt; min_iter) or (num_changed &gt; stopping_crit and count &lt; max_iter):
        Rin = u&gt;0; Rout = u&lt;=0
        Iin = I[Rin]; Iout = I[Rout]
        tin = np.sum(Rin); tout= np.sum(Rout)

        cin = 0; cout =0
        if tin &gt; 0:
           cin = np.mean(Iin)
        if tout &gt; 0:
           cout = np.mean(Iout)
        num_changed = abs(tin - tin_old)
        tin_old = tin;

        #Compute gradient
        GE = u[Yp,:] - u 
        GW = u[Ym,:] - u
        GN = u[:,Xm] - u  
        GS = u[:,Xp] - u 

        delta = eps/(np.pi*(eps**2 + u**2))
        div = (GN/np.sqrt(eps**2 + GN**2) + GE/np.sqrt(eps**2 + GE**2) + GS/np.sqrt(eps**2 + GS**2) + GW/np.sqrt(eps**2 + GW**2))
        fid = (I - cout)**2 - (I - cin)**2

        u = u + dt*delta*(lam*div + fid)
    
        if visualize:
            seg.collections[0].remove()
            seg = plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))
            plt.pause(0.01)

        count = count+1;
        print(count)

    if cin &lt; cout:
        u = -u

    return u &gt; 0</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.imshow"><code class="name flex">
<span>def <span class="ident">imshow</span></span>(<span>J)</span>
</code></dt>
<dd>
<div class="desc"><p>Make showing grayscale images easier.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>J</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image to show.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imshow(J):
    &#34;&#34;&#34; Make showing grayscale images easier.

        Parameters
        ----------
        J : float array
            Image to show.

        Returns
        -------
        None
    &#34;&#34;&#34;

    plt.figure()
    plt.imshow(J, cmap=&#39;gray&#39;)</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.process_dicom"><code class="name flex">
<span>def <span class="ident">process_dicom</span></span>(<span>directory, scanlayout, CTdir='ScanOverviews', Meshdir='Meshes', chopsheet=None, threshold=2000, padding=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes all dicom scans from scanlayout in a given directory, producing
CT volumes for each object. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to be working within.</dd>
<dt><strong><code>scanlayout</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>1st column is CT scan data, 2nd column is ScanPacket,
listing the subdirectories for each scan, third column
indicating L2R or R2L, and the next columns indicating
the specimens in that scan</dd>
<dt><strong><code>CTdir</code></strong> :&ensp;<code>str</code>, default <code>is 'ScanOverviews'</code></dt>
<dd>The directory to save all results.</dd>
<dt><strong><code>Meshdir</code></strong> :&ensp;<code>str</code>, default <code>is 'Meshes'</code></dt>
<dd>The directory to save individual bone fragments</dd>
<dt><strong><code>chopsheet</code></strong> :&ensp;<code>default is None</code></dt>
<dd>Gives the option for the user to adjust the automatic chopping of bones.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, default <code>is 2000</code></dt>
<dd>Threshold to use with CT_side_seg function.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, default <code>is 15</code></dt>
<dd>Padding to use when drawing bounding boxes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>Chopsheet recording locations where objects were cropped. Returned only if chopsheet=None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_dicom(directory, scanlayout, CTdir=&#39;ScanOverviews&#39;, Meshdir=&#39;Meshes&#39;, 
                             chopsheet=None, threshold=2000, padding=15):
    &#34;&#34;&#34; Processes all dicom scans from scanlayout in a given directory, producing
        CT volumes for each object. 

        Parameters
        ----------
        directory : str
            Directory to be working within.
        scanlayout : pandas DataFrame
            1st column is CT scan data, 2nd column is ScanPacket, 
            listing the subdirectories for each scan, third column 
            indicating L2R or R2L, and the next columns indicating 
            the specimens in that scan
        CTdir : str, default is &#39;ScanOverviews&#39;
            The directory to save all results. 
        Meshdir : str, default is &#39;Meshes&#39;
            The directory to save individual bone fragments
        chopsheet : default is None
            Gives the option for the user to adjust the automatic chopping of bones.
        threshold : float, default is 2000
            Threshold to use with CT_side_seg function.
        padding : float, default is 15
            Padding to use when drawing bounding boxes.

        Returns
        -------
        df : pandas DataFrame
            Chopsheet recording locations where objects were cropped. Returned only if chopsheet=None.
   &#34;&#34;&#34;

    #Number of bones in each scan
    num_bones = scanlayout.count(axis=1) - 4

    #Number of scans
    num_scans = len(scanlayout)

    #Make CTdir if it doesn&#39;t exist
    if not os.path.isdir(CTdir):
        os.mkdir(CTdir)

    #Make Meshdir if it doesn&#39;t exist
    if not os.path.isdir(Meshdir):
        os.mkdir(Meshdir)
 
    #Dataframe to hold chopsheet
    if chopsheet is None:
        df = pd.DataFrame(columns=[&#39;ScanPacket&#39;,&#39;Process&#39;,&#39;x1&#39;,&#39;x2&#39;,&#39;y1&#39;,&#39;y2&#39;,&#39;z1&#39;,&#39;z2&#39;])

    #Loop over all scans
    for i in range(num_scans):

        #Check if we should process this scan or not
        if (chopsheet is None) or chopsheet[&#39;Process&#39;][i]:

            #Get packet name
            subdir = scanlayout[&#39;ScanPacket&#39;][i]
            if not isinstance(subdir, str):
                subdir = str(subdir)
            d = os.path.join(directory, subdir)
            print(&#39;\nLoading scan &#39; + d + &#39;...&#39;)
            
            #Get bone names
            bone_names = scanlayout.iloc[i, 4:4+num_bones[i]].values.tolist()
            if scanlayout[&#39;CTHead2Tail&#39;][i] ==&#39;R2L&#39;:
                print(&#39;Reversed&#39;)
                bone_names.reverse()

            #Read CT volume
            I, dx, dz, dicom_files = read_dicom_dir(d)

            #Process resolutions and check that they are all the same
            if np.sum(dx[:,0]!=dx[:,1]):
                sys.exit(&#39;Error: x,y resolutions are different!!&#39;)
            dx = dx[:,0]

            dx_mode = stats.mode(dx).mode.flatten()[0]
            dz_mode = stats.mode(dz).mode.flatten()[0]

            ind = (dx != dx_mode) | (dz != dz_mode)
            num_diff = np.sum(ind)
            if num_diff:
                print(&#39;Found %d DICOM images with different resolution, removing those...&#39;%num_diff)
                I = I[~ind,:,:]
            dx = dx_mode
            dz = dz_mode

            if I is not None:

                if chopsheet is None: #Then chop and save to spreadsheet

                    K1 = CT_side_seg(I,num_bones[i],threshold=threshold,axis=1)    
                    K2 = CT_side_seg(I,num_bones[i],threshold=threshold,axis=2)    
                    x1,x2,y1,y2,z1,z2 = bone_bounding_boxes(K1,K2)

                    str_x1 = np.array2string(x1, separator=&#39;,&#39;)
                    str_x2 = np.array2string(x2, separator=&#39;,&#39;)
                    str_y1 = np.array2string(y1, separator=&#39;,&#39;)
                    str_y2 = np.array2string(y2, separator=&#39;,&#39;)
                    str_z1 = np.array2string(z1, separator=&#39;,&#39;)
                    str_z2 = np.array2string(z2, separator=&#39;,&#39;)

                    df = df.append({&#39;ScanPacket&#39;:subdir, &#39;Process&#39;:True, &#39;x1&#39;:str_x1, &#39;x2&#39;:str_x2, 
                                                                         &#39;y1&#39;:str_y1, &#39;y2&#39;:str_y2, 
                                                                         &#39;z1&#39;:str_z1, &#39;z2&#39;:str_z2,}, ignore_index=True)
                else: #Load chop locations from spreadsheet

                    x1 = np.fromstring(chopsheet[&#39;x1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    x2 = np.fromstring(chopsheet[&#39;x2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    y1 = np.fromstring(chopsheet[&#39;y1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    y2 = np.fromstring(chopsheet[&#39;y2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    z1 = np.fromstring(chopsheet[&#39;z1&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)
                    z2 = np.fromstring(chopsheet[&#39;z2&#39;][i][1:-1], sep=&#39;,&#39;).astype(int)

                J = draw_bounding_boxes(I,x1,x2,y1,y2,z1,z2,padding=padding)
                plt.imsave(os.path.join(CTdir, subdir + &#39;.png&#39;), J, cmap=&#39;gray&#39;)

                #Chop, and create overview of CT image of bone
                for j in range(len(bone_names)):
                    bonename = bone_names[j] + &#39;_&#39; + scanlayout[&#39;CT&#39;][i]
                    print(&#39;Saving &#39;+bonename+&#39;...&#39;)

                    #Chop
                    Isub = crop_image(I,x1[j],x2[j],y1[j],y2[j],z1[j],z2[j],padding=padding)

                    #Correct for mirroring on some scans
                    if scanlayout[&#39;Mirrored&#39;][i] == &#39;yes&#39;:
                        print(&#39;Mirrored&#39;)
                        Isub = Isub[::-1,:,:]

                    #Create and save overview of bone
                    Jsub = bone_overview(Isub)
                    plt.imsave(os.path.join(Meshdir,bonename + &#39;.png&#39;), Jsub, cmap=&#39;gray&#39;)

                    #Save 3D bone volume
                    np.savez_compressed(os.path.join(Meshdir,bonename + &#39;.npz&#39;), I=Isub, dx=dx, dz=dz, bonename=bonename)

    if chopsheet is None:
        return df</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.read_dicom_dir"><code class="name flex">
<span>def <span class="ident">read_dicom_dir</span></span>(<span>directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and reads dicom volume from directory; finds the subdirectory with the most dicom files and loads those into a volume.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to read from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>I : Volume of images.
dx : Image resolution dimension.
dz : Image resolution dimension.
dicom_files : List of dicom files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_dicom_dir(directory):
    &#34;&#34;&#34; Finds and reads dicom volume from directory; finds the subdirectory with the most dicom files and loads those into a volume.

        Parameters
        ----------
        directory : str
            Directory to read from.

        Returns
        -------
        I : Volume of images.
        dx : Image resolution dimension.
        dz : Image resolution dimension.
        dicom_files : List of dicom files.
    &#34;&#34;&#34;

    dicom_dir = find_dicom_subdir(directory)
    files = os.listdir(dicom_dir)
    files.sort()
    files = [os.path.join(dicom_dir, f) for f in files]
    return read_dicom_list(files)</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.read_dicom_list"><code class="name flex">
<span>def <span class="ident">read_dicom_list</span></span>(<span>files)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads dicom images from a provided list files, stores in a volume I, and returns resolution dx and dz and a list of files; some may be ommitted if they are not dicom.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>str list</code></dt>
<dd>List of files to read from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>I : Volume of images.
dx : Image resolution dimension.
dz : Image resolution dimension.
dicom_files : List of dicom files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_dicom_list(files):
    &#34;&#34;&#34; Reads dicom images from a provided list files, stores in a volume I, and returns resolution dx and dz and a list of files; some may be ommitted if they are not dicom.

        Parameters
        ----------
        files : str list
            List of files to read from.
        
        Returns
        -------
        I : Volume of images.
        dx : Image resolution dimension.
        dz : Image resolution dimension.
        dicom_files : List of dicom files.
    &#34;&#34;&#34;

    num_slices = len(files)
    dicom_files = []
    i = 0
    for f in files:
        try:
            A = dicom.dcmread(f)
            dicom_files.append(f)
            if i == 0:
                s = A.pixel_array.shape
                I = np.zeros((num_slices, s[0], s[1]), dtype=int)
                dx = np.zeros((num_slices, 2))
                dz = np.zeros(num_slices)
            I[i, :, :] = A.pixel_array
            dx[i, :] = A.PixelSpacing
            dz[i] = A.SliceThickness
            i += 1
        except:
            print(f + &#39; is not a DICOM file.&#39;)

    if i == 0:
        print(&#39;No DICOM files found.&#39;)
        return (None, None, None, None)
    else:
        print(&#39;Found %d DICOM files.&#39; % i)
        return (I[:i, :, :], dx[:i, :], dz[:i], dicom_files)</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.scan_overview"><code class="name flex">
<span>def <span class="ident">scan_overview</span></span>(<span>I, true_mean=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an overview of the scan from top and side.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>true_mean</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, take mean instead.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An overview of scan from top and side.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_overview(I,true_mean=False):
    &#34;&#34;&#34; Returns an overview of the scan from top and side.

        Parameters
        ----------
        I : float array
            Image of scan.
        true_mean : boolean, default is False
            If True, take mean instead.

        Returns
        -------
        An overview of scan from top and side.
    &#34;&#34;&#34;

    if true_mean:
        I1 = np.mean(I,axis=1)
        I2 = np.mean(I,axis=2)
    else:
        I1 = np.sum(I, axis=1)
        I2 = np.sum(I, axis=2)
        I1 = I1 / np.max(I1)
        I2 = I2 / np.max(I2)

    return np.hstack((I1, I2)).T</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.seg_adjacency_matrix"><code class="name flex">
<span>def <span class="ident">seg_adjacency_matrix</span></span>(<span>u)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seg_adjacency_matrix(u):

    n = I.shape[0]
    m = I.shape[1]

    Y,X = np.mgrid[:n,:m]
    X = X.flatten()
    Y = Y.flatten()
    u = u.flatten()

    C = np.ravel_multi_index((X,Y),(m,n),mode=&#39;clip&#39;)
    E = np.ravel_multi_index((X+1,Y),(m,n),mode=&#39;clip&#39;)
    W = np.ravel_multi_index((X-1,Y),(m,n),mode=&#39;clip&#39;)
    N = np.ravel_multi_index((X,Y-1),(m,n),mode=&#39;clip&#39;)
    S = np.ravel_multi_index((X,Y+1),(m,n),mode=&#39;clip&#39;)
    
    WE = u(C) == u(E)
    WW = u(C) == u(W)
    WS = u(C) == u(S)
    WN = u(C) == u(N)

    ME = sparse.coo_matrix((WE, (C,E)),shape=(n*m,n*m)).to_csr()
    MW = sparse.coo_matrix((WW, (C,W)),shape=(n*m,n*m)).to_csr()
    MS = sparse.coo_matrix((WS, (C,S)),shape=(n*m,n*m)).to_csr()
    MN = sparse.coo_matrix((WN, (C,N)),shape=(n*m,n*m)).to_csr()

    M = ME + MW + MS + MN
    M = M - sparse.spdiags(M.diagonal(),0,n*m,n*m)
    
    ind = u &gt; 0
    M = M[u&gt;0,:]
    M = M[:,u&gt;0]
    X = X[u&gt;0]
    Y = Y[u&gt;0]

    return M,X,Y</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.seg_plot"><code class="name flex">
<span>def <span class="ident">seg_plot</span></span>(<span>I, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the segmented image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of a scan.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>boolean array</code></dt>
<dd>The segmentation of that image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seg_plot(I,u):
    &#34;&#34;&#34; Plot the segmented image.

        Parameters
        ----------
        I : float array
            Image of a scan.
        u : boolean array
            The segmentation of that image.

        Returns
        -------
        None
    &#34;&#34;&#34;

    n = I.shape[0]
    m = I.shape[1]
    Y,X = np.mgrid[:n,:m]
    plt.imshow(I,cmap=&#39;gray&#39;)
    plt.axis(&#39;off&#39;)
    plt.contour(X,Y,u,levels=[0],colors=(&#39;r&#39;))</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.surface_bones"><code class="name flex">
<span>def <span class="ident">surface_bones</span></span>(<span>directory, iso=2500, write_gif=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes all npz files in directory creating surface and saving to a ply file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory to work within.</dd>
<dt><strong><code>iso</code></strong> :&ensp;<code>float (optional)</code>, default <code>is 2500</code></dt>
<dd>Iso level to be used for surfacing.</dd>
<dt><strong><code>write_gif</code></strong> :&ensp;<code>bool (optional)</code>, default=<code>False</code></dt>
<dd>Whether to output rotating gifs for each object. Requires mayavi, which can be hard to install.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surface_bones(directory, iso=2500, write_gif=False):
    &#34;&#34;&#34; Processes all npz files in directory creating surface and saving to a ply file.

        Parameters
        ----------
        directory : str
            Directory to work within.
        iso : float (optional), default is 2500
            Iso level to be used for surfacing.
        write_gif : bool (optional), default=False
            Whether to output rotating gifs for each object. Requires mayavi, which can be hard to install.

        Returns
        -------
        None
    &#34;&#34;&#34;

    for filename in os.listdir(directory):
        if filename.endswith(&#34;.npz&#34;):
            print(&#39;Loading &#39;+filename+&#39;...&#39;)
            M = np.load(os.path.join(directory,filename))
            I = M[&#39;I&#39;]; dx = M[&#39;dx&#39;]; dz = M[&#39;dz&#39;]

            #Rescale image to account for different dx/dz dimensions
            J = rescale(I.astype(float),(dz/dx,1,1),mode=&#39;constant&#39;)

            #Marching cubes for isosurface
            iso_level = iso
            verts,faces,normals,values = measure.marching_cubes(J,iso_level)
            mesh = tm.mesh(dx*verts,faces) #Multiplication by dx fixes units

            #Reverse orientation of triangles (marching_cubes returns inward normals)
            mesh.flip_normals()

            #Write to ply file
            mesh_filename = os.path.join(directory,filename[:-4]+&#39;_iso%d&#39;%iso_level)
            print(&#39;Saving mesh to &#39;+mesh_filename+&#39;...&#39;)
            mesh.to_ply(mesh_filename+&#39;.ply&#39;)

            if write_gif:
                mesh.to_gif(mesh_filename+&#39;.gif&#39;)</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>I, v, padding=20, erosion_width=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Trim to v level with padding.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Image of scan.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>Level to be trimmed to.</dd>
<dt><strong><code>padding</code></strong> :&ensp;<code>float</code>, default <code>is 20</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>erosion_width</code></strong> :&ensp;<code>float</code>, default <code>is 5</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>float array</code></dt>
<dd>Trimmed image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(I, v, padding=20, erosion_width=5):
    &#34;&#34;&#34; Trim to v level with padding.

        Parameters
        ----------
        I : float array
            Image of scan.
        v : float
            Level to be trimmed to.
        padding : float, default is 20
        erosion_width : float, default is 5
    
        Returns
        -------
        I : float array
            Trimmed image.
    &#34;&#34;&#34;

    J = I &gt; v

    #Add extra to account for erosion
    #padding = padding + 4*erosion_width

    #kernel = np.ones((3,3), dtype=int)
    #erosion = cv2.erode(J.astype(float),kernel,iterations=erosion_width)
    #J = cv2.dilate(erosion,kernel,iterations=erosion_width)

    K = np.sum(np.sum(J,axis=2),axis=1) &gt; 0
    ind = np.arange(len(K))[K]
    z1 = max(ind.min()-padding,0)
    z2 = min(ind.max()+padding,I.shape[0])

    K = np.sum(np.sum(J,axis=0),axis=1) &gt; 0
    ind = np.arange(len(K))[K]
    x1 = max(ind.min()-padding,0)
    x2 = min(ind.max()+padding,I.shape[1])

    K = np.sum(np.sum(J,axis=0),axis=0) &gt; 0
    ind = np.arange(len(K))[K]
    y1 = max(ind.min()-padding,0)
    y2 = min(ind.max()+padding,I.shape[2])

    return I[z1:z2,x1:x2,y1:y2]</code></pre>
</details>
</dd>
<dt id="amaazetools.dicom.withiness"><code class="name flex">
<span>def <span class="ident">withiness</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes withiness (how well 1-D data clusters into two groups).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>A 1-D collection of data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>The withiness of the data.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>The point at which to split the data into 2 clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def withiness(x):
    &#34;&#34;&#34; Computes withiness (how well 1-D data clusters into two groups).

        Parameters
        ----------
        x : (n,1) float array
            A 1-D collection of data.
        
        Returns
        -------
        w : float
            The withiness of the data.
        m : float
            The point at which to split the data into 2 clusters.
    &#34;&#34;&#34;

    x = np.sort(x)
    sigma = np.std(x)
    n = x.shape[0]
    v = np.zeros(n-1,)
    for i in range(n-1):
        x1 = x[:(i+1)]
        x2 = x[(i+1):]
        m1 = np.mean(x1);
        m2 = np.mean(x2);
        v[i] = (np.sum((x1-m1)**2) + np.sum((x2-m2)**2))/(sigma**2*n);
    ind = np.argmin(v)
    m = x[ind]
    w = v[ind]
    return w,m</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="amaazetools" href="index.html">amaazetools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="amaazetools.dicom.CT_side_seg" href="#amaazetools.dicom.CT_side_seg">CT_side_seg</a></code></li>
<li><code><a title="amaazetools.dicom.add_border" href="#amaazetools.dicom.add_border">add_border</a></code></li>
<li><code><a title="amaazetools.dicom.bone_bounding_boxes" href="#amaazetools.dicom.bone_bounding_boxes">bone_bounding_boxes</a></code></li>
<li><code><a title="amaazetools.dicom.bone_overview" href="#amaazetools.dicom.bone_overview">bone_overview</a></code></li>
<li><code><a title="amaazetools.dicom.chop_up_scan" href="#amaazetools.dicom.chop_up_scan">chop_up_scan</a></code></li>
<li><code><a title="amaazetools.dicom.crop_image" href="#amaazetools.dicom.crop_image">crop_image</a></code></li>
<li><code><a title="amaazetools.dicom.draw_bounding_boxes" href="#amaazetools.dicom.draw_bounding_boxes">draw_bounding_boxes</a></code></li>
<li><code><a title="amaazetools.dicom.find_dicom_subdir" href="#amaazetools.dicom.find_dicom_subdir">find_dicom_subdir</a></code></li>
<li><code><a title="amaazetools.dicom.image_segmentation" href="#amaazetools.dicom.image_segmentation">image_segmentation</a></code></li>
<li><code><a title="amaazetools.dicom.imshow" href="#amaazetools.dicom.imshow">imshow</a></code></li>
<li><code><a title="amaazetools.dicom.process_dicom" href="#amaazetools.dicom.process_dicom">process_dicom</a></code></li>
<li><code><a title="amaazetools.dicom.read_dicom_dir" href="#amaazetools.dicom.read_dicom_dir">read_dicom_dir</a></code></li>
<li><code><a title="amaazetools.dicom.read_dicom_list" href="#amaazetools.dicom.read_dicom_list">read_dicom_list</a></code></li>
<li><code><a title="amaazetools.dicom.scan_overview" href="#amaazetools.dicom.scan_overview">scan_overview</a></code></li>
<li><code><a title="amaazetools.dicom.seg_adjacency_matrix" href="#amaazetools.dicom.seg_adjacency_matrix">seg_adjacency_matrix</a></code></li>
<li><code><a title="amaazetools.dicom.seg_plot" href="#amaazetools.dicom.seg_plot">seg_plot</a></code></li>
<li><code><a title="amaazetools.dicom.surface_bones" href="#amaazetools.dicom.surface_bones">surface_bones</a></code></li>
<li><code><a title="amaazetools.dicom.trim" href="#amaazetools.dicom.trim">trim</a></code></li>
<li><code><a title="amaazetools.dicom.withiness" href="#amaazetools.dicom.withiness">withiness</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
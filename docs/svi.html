<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>amaazetools.svi API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>amaazetools.svi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#svi.py
#Spherical Volume Invariant
import numpy as np
from numpy import matlib
#import amaazetools.cextensions as cext
from . import trimesh as tm
import scipy.sparse as sparse

def vertex_normals(P,T):
    &#34;&#34;&#34;Computes normal vectors to vertices.
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
           List of vertex indices for each triangle in the mesh. 
        
        Returns
        -------
        A (num_verts,3) array containing the vertex normal vectors.
    &#34;&#34;&#34;

    if self.unit_norms is None:
        self.face_normals()
    fn = self.unit_norms
    F = self.tri_vert_adj()
    vn = F@fn
    norms = np.linalg.norm(vn,axis=1)
    norms[norms==0] = 1

    return vn/norms[:,np.newaxis]

def face_normals(P,T,normalize=True):
    &#34;&#34;&#34; Computes normal vectors to triangles (faces).
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh. 
        normalize: boolean, default is True
            Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.
        
        Returns
        -------
        N : (num_tri,3) float array
            Array containing the face normal vectors.
    &#34;&#34;&#34;

    P1 = P[T[:,0],:]
    P2 = P[T[:,1],:]
    P3 = P[T[:,2],:]

    N = np.cross(P2-P1,P3-P1)
    if normalize:
        N = (N.T/np.linalg.norm(N,axis =1)).T
    return N

def tri_vert_adj(P,T,normalize=False):
    &#34;&#34;&#34; Computes a sparse vertex-triangle adjacency matrix.

        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh. 
        normalize : boolean, default is False
            If True, each row is divided by the number of adjacent triangles.

        Returns
        -------
        F : (num_verts,num_tri) boolean array
            Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.
    &#34;&#34;&#34;

    num_verts = P.shape[0]
    num_tri = T.shape[0]
    ind = np.arange(num_tri)

    I = np.hstack((T[:,0],T[:,1],T[:,2]))
    J = np.hstack((ind,ind,ind))
    F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(num_verts,num_tri)).tocsr()

    if normalize:
        num_adj_tri = F@np.ones(num_tri)
        F = sparse.spdiags(1/num_adj_tri,0,num_verts,num_verts)@F

    return F

#Returns unit normal vectors to vertices (averaging adjacent faces and normalizing)
def vertex_normals(P,T):
    &#34;&#34;&#34; Computes normal vectors to vertices.

        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.

        Returns
        -------
        (num_verts,3) float array containing the vertex normal vectors.
    &#34;&#34;&#34;

    fn = face_normals(P,T)
    F = tri_vert_adj(P,T)
    vn = F@fn
    norms = np.linalg.norm(vn,axis=1)
    norms[norms==0] = 1

    return vn/norms[:,np.newaxis]


def svi(P,T,r,ID=None):
    &#34;&#34;&#34; Computes spherical volume invariant.
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.  
        r : (k,1) float array
            List of radii to use.
        ID : (n,1) boolean array, default is None
            Spherical volume is only computed at points with True indices. 
        
        Returns
        -------
        S : (n,1) float array
            The volumes corresponding to each point.
        G : (n,1) float array
            The  gamma values corresponding to each point.
    &#34;&#34;&#34;

    n = P.shape[0]  #Number of vertices
    rlen = np.max(np.shape(r))
    
    if ID is None:
        ID = np.full((n), True)
    
    #Bool indicating at which vertices to compute SVI 
    Sout = np.zeros((n,rlen), dtype=np.float64) #Stores output SVI
    Gout = np.zeros((n,rlen), dtype=np.float64) #Stores output Gamma
    eps = 1.0       #Integration error tolerance
    prog = 1.0      #Show progress (1=yes, 0=no)
    
    #Output arrays
    S = np.zeros((n), dtype=np.float64)
    G = np.zeros((n), dtype=np.float64)

    #Contiguous arrays
    T = np.ascontiguousarray(T,dtype=np.int32)
    P = np.ascontiguousarray(P,dtype=np.float64)

    #Run SVI code
    for i in np.arange(0,rlen): 
        cext.svi(P,T,ID,r[i],eps,prog,S,G)
        Sout[:,i] = S
        Gout[:,i] = G

    return Sout,Gout

def svipca(P,T,r,ID = None):
    &#34;&#34;&#34; Computes SVIPCA
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.  
        r : (k,1) float array
            List of radii to use.
        ID : (n,1) boolean array, default is None
            Spherical volume is only computed at points with True indices.         

        Returns
        -------
        Sout : (n,1) float array
            The volumes corresponding to each point.
        K1 : (n,1) float array
            The first principle curvature for each point.
        K2 : (n,1) float array
            The second principle curvature for each point.
        V1 : (n,3) float array
            The first principal direction for each point. 
        V2 : (n,3) float array
            The second principal direction for each point.
        V3 : (n,3) float array
            The third principal direction for each point.
    &#34;&#34;&#34;

    n = P.shape[0]  #Number of vertices
    rlen = np.max(np.shape(r))
         
    eps_svi = 1.0       #Integration error tolerance for svi
    eps_pca = 1.0
    prog = 1.0      #Show progress (1=yes, 0=no)
    
    if ID is None:
        ID = np.full((n), True)
    
    Sout = np.zeros((n,rlen), dtype=np.float64) #Stores output SVI
    K1 = np.zeros((n,rlen), dtype=np.float64)                              
    K2 = np.zeros((n,rlen), dtype=np.float64)
    V1 = np.zeros((n,3*rlen), dtype=np.float64)
    V2 = np.zeros((n,3*rlen), dtype=np.float64)
    V3 = np.zeros((n,3*rlen), dtype=np.float64)
        
    S = np.zeros((n), dtype=np.float64)
    M = np.zeros((9*n), dtype=np.float64) #Stores output PCA matrix
        
    #VN = tm.vertex_normals(P,T)
    VN = vertex_normals(P,T)
        
    #indexing for output:
    I = np.arange(0,n)
    I = I[I]
        
    #Contiguous arrays
    T = np.ascontiguousarray(T,dtype=np.int32)
    P = np.ascontiguousarray(P,dtype=np.float64)

    for k in np.arange(0,rlen):
        cext.svipca(P,T,ID,r[k],eps_svi,eps_pca,prog,S,M)
        Sout[:,k] = S
        
        l = np.arange(3*k,3*k+3)
            
        L1 = np.zeros((n), dtype=np.float64)
        L2 = np.zeros((n), dtype=np.float64)
        L3 = np.zeros((n), dtype=np.float64)
        
        for i in I:
            A = M[np.arange(9*i,9*(i+1))]
            D,V = np.linalg.eig([A[[0,1,2]],A[[3,4,5]],A[[6,7,8]]])
    
            a = VN[i,:]@V
    
            loc = np.where(np.abs(a)==max(np.abs(a)))
            
            if loc == 0:
                L1[i] = D[1]
                L2[i] = D[2]
                L3[i] = D[0]
                V1[i,l] = V[:,1]
                V2[i,l] = V[:,2]
                V3[i,l] = V[:,0]
            elif loc==1:
                L1[i] = D[0]
                L2[i] = D[2]
                L3[i] = D[1]
                V1[i,l] = V[:,0]
                V2[i,l] = V[:,1]
                V3[i,l] = V[:,2]
            else:
                L1[i] = D[0]
                L2[i] = D[1]
                L3[i] = D[2]
                V1[i,l] = V[:,0]
                V2[i,l] = V[:,1]
                V3[i,l] = V[:,2]
         
        Kdiff = (L1-L2)*24/(np.pi*r[k]**6);
        Ksum = 16*np.pi*(r[k]**3)/3 - 8*S/(np.pi*r[k]**4)
        k1t = (Kdiff + Ksum)/2;
        k2t = (Ksum - Kdiff)/2;
            
        #want to ensure k1&gt;k2:
        J = np.double(k1t &gt; k2t); #logical
        
        K1[:,k]= J*k1t + (1-J)*k2t #if k1 max, keep it as k1, else swap
        K2[:,k] = (1-J)*k1t + J*k2t 
        v1t = V1[:,l] 
        v2t = V2[:,l]
        V1[:,l] = J[:,None]*v1t + (1-J[:,None])*v2t #so V1 corresponds to K1
        V2[:,l] = (1-J[:,None])*v1t + J[:,None]*v2t
               
        #now for quality control: if volume is not defined:
        visnegative = S == -1;
        vvneg = matlib.repmat(np.double(visnegative[:,None]==0),1,3)
        K1[visnegative,k] = 0; 
        K2[visnegative,k] = 0;
        V1[:,l] = vvneg*V1[:,l]    
        V2[:,l] = vvneg*V2[:,l]
        V3[:,l] = vvneg*V3[:,l]
        
        vecneg = -2*(np.double(np.sum(V3[:,l]*VN&lt;0,1)&lt;0)-.5)
        vecneg = matlib.repmat(vecneg[:,None],1,3)
        V3[:,l] = vecneg*V3[:,l];
        V2[:,l] = vecneg*V2[:,l];
        V1[:,l] = vecneg*V1[:,l];
              
        #implementing right hand rule:
        rhr = -2*(np.double(np.sum(V3[:,l]*np.cross(V1[:,l],V2[:,l]),1) &lt; 0)-.5);
        rhr = matlib.repmat(rhr[:,None],1,3)
        V1[:,l] = rhr*V1[:,l]   
    return Sout,K1,K2,V1,V2,V3</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="amaazetools.svi.face_normals"><code class="name flex">
<span>def <span class="ident">face_normals</span></span>(<span>P, T, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes normal vectors to triangles (faces).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(m,3) int array</code></dt>
<dd>List of vertex indices for each triangle in the mesh.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>boolean</code>, default <code>is True</code></dt>
<dd>Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>(num_tri,3) float array</code></dt>
<dd>Array containing the face normal vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_normals(P,T,normalize=True):
    &#34;&#34;&#34; Computes normal vectors to triangles (faces).
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh. 
        normalize: boolean, default is True
            Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.
        
        Returns
        -------
        N : (num_tri,3) float array
            Array containing the face normal vectors.
    &#34;&#34;&#34;

    P1 = P[T[:,0],:]
    P2 = P[T[:,1],:]
    P3 = P[T[:,2],:]

    N = np.cross(P2-P1,P3-P1)
    if normalize:
        N = (N.T/np.linalg.norm(N,axis =1)).T
    return N</code></pre>
</details>
</dd>
<dt id="amaazetools.svi.svi"><code class="name flex">
<span>def <span class="ident">svi</span></span>(<span>P, T, r, ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes spherical volume invariant.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(m,3) int array</code></dt>
<dd>List of vertex indices for each triangle in the mesh.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>(k,1) float array</code></dt>
<dd>List of radii to use.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>(n,1) boolean array</code>, default <code>is None</code></dt>
<dd>Spherical volume is only computed at points with True indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The volumes corresponding to each point.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The
gamma values corresponding to each point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def svi(P,T,r,ID=None):
    &#34;&#34;&#34; Computes spherical volume invariant.
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.  
        r : (k,1) float array
            List of radii to use.
        ID : (n,1) boolean array, default is None
            Spherical volume is only computed at points with True indices. 
        
        Returns
        -------
        S : (n,1) float array
            The volumes corresponding to each point.
        G : (n,1) float array
            The  gamma values corresponding to each point.
    &#34;&#34;&#34;

    n = P.shape[0]  #Number of vertices
    rlen = np.max(np.shape(r))
    
    if ID is None:
        ID = np.full((n), True)
    
    #Bool indicating at which vertices to compute SVI 
    Sout = np.zeros((n,rlen), dtype=np.float64) #Stores output SVI
    Gout = np.zeros((n,rlen), dtype=np.float64) #Stores output Gamma
    eps = 1.0       #Integration error tolerance
    prog = 1.0      #Show progress (1=yes, 0=no)
    
    #Output arrays
    S = np.zeros((n), dtype=np.float64)
    G = np.zeros((n), dtype=np.float64)

    #Contiguous arrays
    T = np.ascontiguousarray(T,dtype=np.int32)
    P = np.ascontiguousarray(P,dtype=np.float64)

    #Run SVI code
    for i in np.arange(0,rlen): 
        cext.svi(P,T,ID,r[i],eps,prog,S,G)
        Sout[:,i] = S
        Gout[:,i] = G

    return Sout,Gout</code></pre>
</details>
</dd>
<dt id="amaazetools.svi.svipca"><code class="name flex">
<span>def <span class="ident">svipca</span></span>(<span>P, T, r, ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes SVIPCA</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(m,3) int array</code></dt>
<dd>List of vertex indices for each triangle in the mesh.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>(k,1) float array</code></dt>
<dd>List of radii to use.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>(n,1) boolean array</code>, default <code>is None</code></dt>
<dd>Spherical volume is only computed at points with True indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Sout</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The volumes corresponding to each point.</dd>
<dt><strong><code>K1</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The first principle curvature for each point.</dd>
<dt><strong><code>K2</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The second principle curvature for each point.</dd>
<dt><strong><code>V1</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The first principal direction for each point.</dd>
<dt><strong><code>V2</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The second principal direction for each point.</dd>
<dt><strong><code>V3</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The third principal direction for each point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def svipca(P,T,r,ID = None):
    &#34;&#34;&#34; Computes SVIPCA
        
        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.  
        r : (k,1) float array
            List of radii to use.
        ID : (n,1) boolean array, default is None
            Spherical volume is only computed at points with True indices.         

        Returns
        -------
        Sout : (n,1) float array
            The volumes corresponding to each point.
        K1 : (n,1) float array
            The first principle curvature for each point.
        K2 : (n,1) float array
            The second principle curvature for each point.
        V1 : (n,3) float array
            The first principal direction for each point. 
        V2 : (n,3) float array
            The second principal direction for each point.
        V3 : (n,3) float array
            The third principal direction for each point.
    &#34;&#34;&#34;

    n = P.shape[0]  #Number of vertices
    rlen = np.max(np.shape(r))
         
    eps_svi = 1.0       #Integration error tolerance for svi
    eps_pca = 1.0
    prog = 1.0      #Show progress (1=yes, 0=no)
    
    if ID is None:
        ID = np.full((n), True)
    
    Sout = np.zeros((n,rlen), dtype=np.float64) #Stores output SVI
    K1 = np.zeros((n,rlen), dtype=np.float64)                              
    K2 = np.zeros((n,rlen), dtype=np.float64)
    V1 = np.zeros((n,3*rlen), dtype=np.float64)
    V2 = np.zeros((n,3*rlen), dtype=np.float64)
    V3 = np.zeros((n,3*rlen), dtype=np.float64)
        
    S = np.zeros((n), dtype=np.float64)
    M = np.zeros((9*n), dtype=np.float64) #Stores output PCA matrix
        
    #VN = tm.vertex_normals(P,T)
    VN = vertex_normals(P,T)
        
    #indexing for output:
    I = np.arange(0,n)
    I = I[I]
        
    #Contiguous arrays
    T = np.ascontiguousarray(T,dtype=np.int32)
    P = np.ascontiguousarray(P,dtype=np.float64)

    for k in np.arange(0,rlen):
        cext.svipca(P,T,ID,r[k],eps_svi,eps_pca,prog,S,M)
        Sout[:,k] = S
        
        l = np.arange(3*k,3*k+3)
            
        L1 = np.zeros((n), dtype=np.float64)
        L2 = np.zeros((n), dtype=np.float64)
        L3 = np.zeros((n), dtype=np.float64)
        
        for i in I:
            A = M[np.arange(9*i,9*(i+1))]
            D,V = np.linalg.eig([A[[0,1,2]],A[[3,4,5]],A[[6,7,8]]])
    
            a = VN[i,:]@V
    
            loc = np.where(np.abs(a)==max(np.abs(a)))
            
            if loc == 0:
                L1[i] = D[1]
                L2[i] = D[2]
                L3[i] = D[0]
                V1[i,l] = V[:,1]
                V2[i,l] = V[:,2]
                V3[i,l] = V[:,0]
            elif loc==1:
                L1[i] = D[0]
                L2[i] = D[2]
                L3[i] = D[1]
                V1[i,l] = V[:,0]
                V2[i,l] = V[:,1]
                V3[i,l] = V[:,2]
            else:
                L1[i] = D[0]
                L2[i] = D[1]
                L3[i] = D[2]
                V1[i,l] = V[:,0]
                V2[i,l] = V[:,1]
                V3[i,l] = V[:,2]
         
        Kdiff = (L1-L2)*24/(np.pi*r[k]**6);
        Ksum = 16*np.pi*(r[k]**3)/3 - 8*S/(np.pi*r[k]**4)
        k1t = (Kdiff + Ksum)/2;
        k2t = (Ksum - Kdiff)/2;
            
        #want to ensure k1&gt;k2:
        J = np.double(k1t &gt; k2t); #logical
        
        K1[:,k]= J*k1t + (1-J)*k2t #if k1 max, keep it as k1, else swap
        K2[:,k] = (1-J)*k1t + J*k2t 
        v1t = V1[:,l] 
        v2t = V2[:,l]
        V1[:,l] = J[:,None]*v1t + (1-J[:,None])*v2t #so V1 corresponds to K1
        V2[:,l] = (1-J[:,None])*v1t + J[:,None]*v2t
               
        #now for quality control: if volume is not defined:
        visnegative = S == -1;
        vvneg = matlib.repmat(np.double(visnegative[:,None]==0),1,3)
        K1[visnegative,k] = 0; 
        K2[visnegative,k] = 0;
        V1[:,l] = vvneg*V1[:,l]    
        V2[:,l] = vvneg*V2[:,l]
        V3[:,l] = vvneg*V3[:,l]
        
        vecneg = -2*(np.double(np.sum(V3[:,l]*VN&lt;0,1)&lt;0)-.5)
        vecneg = matlib.repmat(vecneg[:,None],1,3)
        V3[:,l] = vecneg*V3[:,l];
        V2[:,l] = vecneg*V2[:,l];
        V1[:,l] = vecneg*V1[:,l];
              
        #implementing right hand rule:
        rhr = -2*(np.double(np.sum(V3[:,l]*np.cross(V1[:,l],V2[:,l]),1) &lt; 0)-.5);
        rhr = matlib.repmat(rhr[:,None],1,3)
        V1[:,l] = rhr*V1[:,l]   
    return Sout,K1,K2,V1,V2,V3</code></pre>
</details>
</dd>
<dt id="amaazetools.svi.tri_vert_adj"><code class="name flex">
<span>def <span class="ident">tri_vert_adj</span></span>(<span>P, T, normalize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a sparse vertex-triangle adjacency matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(m,3) int array</code></dt>
<dd>List of vertex indices for each triangle in the mesh.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, each row is divided by the number of adjacent triangles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>F</code></strong> :&ensp;<code>(num_verts,num_tri) boolean array</code></dt>
<dd>Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_vert_adj(P,T,normalize=False):
    &#34;&#34;&#34; Computes a sparse vertex-triangle adjacency matrix.

        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh. 
        normalize : boolean, default is False
            If True, each row is divided by the number of adjacent triangles.

        Returns
        -------
        F : (num_verts,num_tri) boolean array
            Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.
    &#34;&#34;&#34;

    num_verts = P.shape[0]
    num_tri = T.shape[0]
    ind = np.arange(num_tri)

    I = np.hstack((T[:,0],T[:,1],T[:,2]))
    J = np.hstack((ind,ind,ind))
    F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(num_verts,num_tri)).tocsr()

    if normalize:
        num_adj_tri = F@np.ones(num_tri)
        F = sparse.spdiags(1/num_adj_tri,0,num_verts,num_verts)@F

    return F</code></pre>
</details>
</dd>
<dt id="amaazetools.svi.vertex_normals"><code class="name flex">
<span>def <span class="ident">vertex_normals</span></span>(<span>P, T)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes normal vectors to vertices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(m,3) int array</code></dt>
<dd>List of vertex indices for each triangle in the mesh.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(num_verts,3) float array containing the vertex normal vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_normals(P,T):
    &#34;&#34;&#34; Computes normal vectors to vertices.

        Parameters
        ----------
        P : (n,3) float array
            A point cloud.
        T : (m,3) int array
            List of vertex indices for each triangle in the mesh.

        Returns
        -------
        (num_verts,3) float array containing the vertex normal vectors.
    &#34;&#34;&#34;

    fn = face_normals(P,T)
    F = tri_vert_adj(P,T)
    vn = F@fn
    norms = np.linalg.norm(vn,axis=1)
    norms[norms==0] = 1

    return vn/norms[:,np.newaxis]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="amaazetools" href="index.html">amaazetools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="amaazetools.svi.face_normals" href="#amaazetools.svi.face_normals">face_normals</a></code></li>
<li><code><a title="amaazetools.svi.svi" href="#amaazetools.svi.svi">svi</a></code></li>
<li><code><a title="amaazetools.svi.svipca" href="#amaazetools.svi.svipca">svipca</a></code></li>
<li><code><a title="amaazetools.svi.tri_vert_adj" href="#amaazetools.svi.tri_vert_adj">tri_vert_adj</a></code></li>
<li><code><a title="amaazetools.svi.vertex_normals" href="#amaazetools.svi.vertex_normals">vertex_normals</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
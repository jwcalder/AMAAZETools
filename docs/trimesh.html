<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>amaazetools.trimesh API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>amaazetools.trimesh</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#tri_mesh.py
#Class for working with triangulated meshes

#test

import graphlearning as gl
import numpy as np
from numpy import matlib
from plyfile import PlyData, PlyElement
import scipy.sparse as sparse
import scipy.spatial as spatial
from sklearn.neighbors import NearestNeighbors
from . import svi
from . import edge_detection
import sys
import urllib.request as url


#Enable plotting if possible
try:
    from mayavi import mlab
    from pyface.api import GUI
    import moviepy.editor as mpy
except:
    print(&#34;Could not find mayavi, plotting functionality will be disabled.&#34;)

#Non-Class Specific Functions

def withiness(x):
    &#34;&#34;&#34; Computes withiness (how well 1-D data clusters into two groups).

        Parameters
        ----------
        x : (n,1) float array
            A 1-D collection of data.
        
        Returns
        -------
        w : float
            The withiness of the data.
        m : float
            The point at which to split the data into 2 clusters.
    &#34;&#34;&#34;

    x = np.sort(x)
    sigma = np.std(x)
    n = x.shape[0]
    v = np.zeros(n-1,)
    for i in range(n-1):
        x1 = x[:(i+1)]
        x2 = x[(i+1):]
        m1 = np.mean(x1);
        m2 = np.mean(x2);
        v[i] = (np.sum((x1-m1)**2) + np.sum((x2-m2)**2))/(sigma**2*n);
    ind = np.argmin(v)
    m = x[ind]
    w = v[ind]
    return w,m

def pca(P):
    &#34;&#34;&#34; Computes principal component analysis (PCA) on a point cloud P.

        Parameters
        ----------
        P : (n,d) float array
            A point cloud.
        
        Returns
        -------
        vals : (d,) float arrayy
            The variances among each principal component.
        vecs : (d,d) float array
            The principal component vectors.
        sign : boolean
            True when the first principal component direction is positively oriented.
    &#34;&#34;&#34;
        
    P = P - np.mean(P,axis=0)
    vals,vecs = np.linalg.eig(P.T@P)
    sign = np.max(vecs[0,:]) &gt; 0

    return vals,vecs,sign
 
def weighted_pca(P,W):
    &#34;&#34;&#34; Computes weighted principal component analysis (PCA) on a point cloud P.

        Parameters
        ----------
        P : (n,d) float array
            A point cloud.
        W : (n,1) float array
            An array containing the weights of the points.
        
        Returns
        -------
        vals : (d,) float array
            The variances among each principal component.
        vecs : (d,d) float array
            The principal component vectors.
        sign : boolean
            True when the first principal component direction is positively oriented.
    &#34;&#34;&#34;

    P = P - np.mean(W*P,axis=0)
    vals,vecs = np.linalg.eig(P.T@(W*P))
    sign = np.max(vecs[0,:]) &gt; 0

    return vals,vecs,sign

#Power method to find principle eigenvector
def power_method(A,tol=1e-12):
    &#34;&#34;&#34; Computes the smallest (in absolute value) eigenvalue and its corresponding eigenvector using the power method.

        Parameters
        ----------
        A : (n,n) float array
            A square matrix that one wishes to find the smallest (in absolute value) eigenvalue and corresponding eigenvector of.
        tol : float, default is 1e-12
            The desired tolerance threshold after which to stop iteration.
        
        Parameters
        ----------
        l : float
            The smallest (in absolute value) eigenvalue of A.
        x : (n,1) float array
            Array containing the eigenvector corresponding to the smallest (in absolute value) eigenvalue of A.
    &#34;&#34;&#34;

    n = A.shape[0]
    x = np.random.rand(n,1)
    err = 1
    i = 1
    while err &gt; tol:
        x = A@x
        x = x/np.linalg.norm(x)
        l = np.transpose(x)@A@x
        err = np.linalg.norm(A@x - l*x)
        i = i+1
    return l,x

def pca_smallest_eig_powermethod(X,center=True):
    &#34;&#34;&#34; Computes the last principal component of a point cloud X using the power method.

        Parameters
        ----------
        X : (n,3) float array
            A point cloud.
        center : boolean, default is True
            Data is centered if True.
        
        Returns
        -------
        A float array of size (3,) containing the last principal component vector.
    &#34;&#34;&#34;

    if center:
        m = np.mean(X,axis=0)
        cov = np.transpose(X-m)@(X-m)/X.shape[0]
    else:
        cov = np.transpose(X)@X/X.shape[0]
    lmax,v = power_method(cov)
    w,v = np.linalg.eig(cov)
    l,v = power_method(cov - (lmax+1)*np.eye(3))
    return v.flatten()

def pca_smallest_eig(X,center=True):
    &#34;&#34;&#34; Computes the last principal component of a point cloud X.

        Parameters
        ----------
        X : (n,3) float array
            A point cloud.
        center : boolean, default is True
            Data is centered if True.
        
        Returns
        -------
        A float array of size (3,) containing the last principal component vector.
    &#34;&#34;&#34;

    if center:
        m = np.mean(X,axis=0)
        cov = np.transpose(X-m)@(X-m)
    else:
        cov = np.transpose(X)@X
    w,v = np.linalg.eig(cov)
    i = np.argmin(w)
    return v[:,i]

### Mesh Class ###

#Read a ply file
def read_ply(fname):
    &#34;&#34;&#34; Reads the vertex and triangle data stored in a .ply file.

        Parameters
        ----------
        fname: str
            Name of the file to read from.
        
        Returns
        -------
        P : (num_verts,3) float array
            The coordinates of the vertices of the mesh.
        T : (num_tri,3) int array
            The indices of the triangles of the mesh.
    &#34;&#34;&#34;

    plydata = PlyData.read(fname)

    #Convert data formats
    try:
        tri_data = plydata[&#39;face&#39;].data[&#39;vertex_indices&#39;]
    except:
        tri_data = plydata[&#39;face&#39;].data[&#39;vertex_index&#39;]

    T = np.vstack(tri_data)
    x = plydata[&#39;vertex&#39;].data[&#39;x&#39;]
    y = plydata[&#39;vertex&#39;].data[&#39;y&#39;]
    z = plydata[&#39;vertex&#39;].data[&#39;z&#39;]
    P = np.vstack((x,y,z))
    P = P.transpose()

    return P,T.astype(int)

#Load a ply file
def load_ply(path):
    &#34;&#34;&#34; Loads a file path or url and creates a mesh object.

        Parameters
        ----------
        path : str
            URL or file path at which to access .ply file.
    
        Returns
        -------
        A mesh object generated from a .ply file found at the file path location.
    &#34;&#34;&#34;

    try:
      url.urlopen(path)
      is_url = True
    except:
      is_url = False

    if is_url:
      fname = path.rsplit(&#39;/&#39;, 1)[-1]
      url.urlretrieve(path,fname)
    else:
      fname = path

    points,triangles = read_ply(fname)
    return mesh(points,triangles)

class mesh:

    def __init__(self,*args):
        self.points = args[0]
        self.triangles = args[1]
        self.unit_norms = None
        self.norms = None
        self.centers = None
        self.knn_I = None
        self.knn_J = None
        self.knn_D = None
        self.tri_vert_adj_I = None
        self.tri_vert_adj_J = None
        self.poisson_W_matrix = None
        self.poisson_J_matrix = None
        self.poisson_node_idx = None
        self.poisson_labels = None

    #Get number of vertices
    def num_verts(self):
        &#34;&#34;&#34; Computes number of vertices in the mesh.

            Returns
            -------
            The number of vertices in the mesh as an integer.
        &#34;&#34;&#34;

        return self.points.shape[0]

    #Get number of triangles
    def num_tri(self):
        &#34;&#34;&#34; Computes number of triangles in the mesh.

            Returns
            -------
            The number of triangles in the mesh as an integer.
        &#34;&#34;&#34;

        return self.triangles.shape[0]

    #Converts from (x,y,z) to index of closest point
    def get_index(self,point):
        &#34;&#34;&#34; Computes the index of a given point.

            Parameters
            ----------
            point : int or (1,3) float array
                A vertex in the mesh, specified by either an integer index or its coordinates.

            Returns
            -------
            The index of the given point as an integer.
        &#34;&#34;&#34;

        if type(point) in [np.int,np.int32,np.int64]:
            point_ind=point
        elif type(point) == np.ndarray and len(point)==3:
            point_ind = np.argmin(np.linalg.norm(self.points - point,axis=1))
        elif type(point) in [tuple,list] and len(point)==3:
            point_ind = np.argmin(np.linalg.norm(self.points - np.array(point),axis=1))
        else:
            sys.exit(&#34;&#39;point&#39; must be an integer index, or a length 3 list, tuple, or numpy ndarray (x,y,z)&#34;)
        return point_ind

    def edge_points(self,u,k=7,return_mask=False,number=None):
        &#34;&#34;&#34; Computes the edge points of the mesh.

            Parameters
            ----------
            u : (num_verts,1) int array
                Array of labels for each point.
            k : int, default is 7
                Number of nearest neighbors to use.
            return_mask : boolean, default is False
                If True, return edge_points as a (num,verts,) boolean array.
            number : int, default is None
                Max number of edge points to return.

            Returns
            -------
            An int array containing the edge point indices.
        &#34;&#34;&#34;

        if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
            self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
        I = self.knn_I[:,:k]
        J = self.knn_J[:,:k]
        D = self.knn_D[:,:k]
        W = gl.weight_matrix(I,J,D,k,f=lambda x : np.ones_like(x),symmetrize=False)
        d = gl.degrees(W)
        mask = d*u != W@u

        #Select a few points spaced out along edge
        if number is not None:
            edge_ind = np.arange(self.num_verts())[mask]
            edge_points = self.points[mask,:]
            num_edge_points = len(edge_points)

            #PCA
            mean = np.mean(edge_points,axis=0)
            cov = (edge_points-mean).T@(edge_points-mean)
            l,v = sparse.linalg.eigs(cov,k=1,which=&#39;LM&#39;)
            proj = (edge_points-mean)@v.real

            #Sort along princpal axis
            sort_ind = np.argsort(proj.flatten())
            dx = (num_edge_points-1)/(number-1)
            spaced_edge_ind = edge_ind[sort_ind[np.arange(0,num_edge_points,dx).astype(int)]]
            mask = np.zeros(self.num_verts(),dtype=bool)
            mask[spaced_edge_ind]=True

        if return_mask:
            return mask.astype(int)
        else: #return indices
            return np.arange(self.num_verts())[mask]

    def geodesic_patch(self,point,r,k=7,return_mask=False):
        &#34;&#34;&#34; Computes a geodesic patch around a specified point.

            Parameters
            ----------
            point : int or (1,3) float array
                A mesh vertex.
            r : float
                Radius used to build patch.
            k : int, default is 7
                Number of nearest neighbors to use.
            return_mask : boolean, default is False
                If True, return the patch as a (num,verts,) boolean array

            Returns
            -------
            An int array containing the patch point indices.
        &#34;&#34;&#34;

        if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
            self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
        I = self.knn_I[:,:k]
        J = self.knn_J[:,:k]
        D = self.knn_D[:,:k]
        W = gl.dist_matrix(I,J,D,k)

        point_ind = self.get_index(point)
        dist = gl.cDijkstra(W,np.array([point_ind]),np.array([0]))
        mask = dist &lt; r

        if return_mask:
            return mask.astype(int)
        else: #return indices
            return np.arange(self.num_verts())[mask]

    #vertex-triangle adjacencey matrix
    #Returns num_verts x num_tri sparse matrix F with F_ij = 1 if vertex i belongs to triangle j
    #If normalize=True, then each row is divided by the number of adjacent triangles,
    #so F can be used to interplate from triangles to vertices
    def tri_vert_adj(self,normalize=False):
        &#34;&#34;&#34; Computes a sparse vertex-triangle adjacency matrix.
       
            Parameters
            ----------
            normalize : boolean, default is False
                If True, each row is divided by the number of adjacent triangles.

            Returns
            -------
            F : (num_verts,num_tri) boolean array
                Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.
        &#34;&#34;&#34;

        num_verts = self.num_verts()
        ind = np.arange(self.num_tri())

        if np.any(self.tri_vert_adj_I) is None or np.any(self.tri_vert_adj_J) is None:
            self.tri_vert_adj_I = np.hstack((self.triangles[:,0],self.triangles[:,1],self.triangles[:,2]))
            self.tri_vert_adj_J = np.hstack((ind,ind,ind))
        I = self.tri_vert_adj_I
        J = self.tri_vert_adj_J
        F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(self.num_verts(),self.num_tri())).tocsr()

        if normalize:
            num_adj_tri = F@np.ones(self.num_tri())
            F = sparse.spdiags(1/num_adj_tri,0,self.num_verts(),self.num_verts())@F

        return F

    #Returns unit normal vectors to vertices (averaging adjacent faces and normalizing)
    def vertex_normals(self):
        &#34;&#34;&#34; Computes normal vectors to vertices.
        
            Returns
            -------
            A (num_verts,3) float array containing the vertex normal vectors.
        &#34;&#34;&#34;

        if self.unit_norms is None:
            self.face_normals()
        fn = self.unit_norms
        F = self.tri_vert_adj()
        vn = F@fn
        norms = np.linalg.norm(vn,axis=1)
        norms[norms==0] = 1

        return vn/norms[:,np.newaxis]
                  
    #Returns unit normal vectors
    def face_normals(self,normalize=True):
        &#34;&#34;&#34; Computes normal vectors to triangles (faces).
        
            Parameters
            ----------
            normalize: boolean, default is True
                Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.
        
            Returns
            -------
            N : (num_tri,3) float array
                Array containing the face normal vectors.
        &#34;&#34;&#34;

        P1 = self.points[self.triangles[:,0],:]
        P2 = self.points[self.triangles[:,1],:]
        P3 = self.points[self.triangles[:,2],:]

        N = np.cross(P2-P1,P3-P1)
        if normalize:
            N = (N.T/np.linalg.norm(N,axis=1)).T
            self.unit_norms = N
            return N
        else:
          self.norms = N
          return N
          
    def flip_normals(self):
        &#34;&#34;&#34; Reverses the orientation of all normal vectors in the mesh
        &#34;&#34;&#34;

        self.Triangles = self.Triangles[:,::-1]

    #Areas of all triangles in mesh
    def tri_areas(self):
        &#34;&#34;&#34; Computes areas of all triangles in the mesh.
        
            Returns
            -------
            A (num_tri,) float array containing the areas of each triangle (face).
        &#34;&#34;&#34;

        if self.norms is None:
            self.face_normals(False)
        return np.linalg.norm(self.norms,axis=1)/2

    #Surface area of mesh
    def surf_area(self):
        &#34;&#34;&#34; Computes surface area of the mesh.
        
            Returns
            -------
            The surface area of the entire mesh as a float.
        &#34;&#34;&#34;

        return np.sum(self.tri_areas())
       
    #Centers of each face
    def face_centers(self):
        &#34;&#34;&#34; Computes coordinates of the center of each triangle (face).
        
            Returns
            -------
            A (num_tri,3) float array containing the coordinates of the face centers.
        &#34;&#34;&#34;

        P1 = self.points[self.triangles[:,0],:]
        P2 = self.points[self.triangles[:,1],:]
        P3 = self.points[self.triangles[:,2],:]

        result = (P1 + P2 + P3)/3
        self.centers = result
        return result
       
    #Volume enclosed by mesh
    def volume(self):
        &#34;&#34;&#34; Computes the volume of the mesh.
        
            Returns
            -------
            The volume of the mesh as a float.
        &#34;&#34;&#34;

        if self.centers is None:
            self.face_centers()
        X = self.centers
        X = X - np.mean(X,axis=0)
        if self.norms is None:
            self.face_normals(False)
        return np.sum(X*self.norms)/6
   
    def bbox(self):
        &#34;&#34;&#34; Computes the bounding box of the mesh.
        
            Returns
            -------
            A (3,) float array containing the dimensions of the bounding box.
        &#34;&#34;&#34;

        if self.centers is None:
            self.face_centers()
        X = self.centers
        n = X.shape[0]
        A = self.tri_areas()

        W = sparse.spdiags(A**2,0,n,n)
        vals,vecs = weighted_pca(X,W)

        vecs = vecs.T
        X = X - np.mean(W*X,axis=0)
        m1 = np.sum(X*vecs[0,:],axis=1)
        l1 = np.max(m1) - np.min(m1)
        m2 = np.sum(X*vecs[1,:],axis=1)
        l2 = np.max(m2) - np.min(m2)
        m3 = np.sum(X*vecs[2,:],axis=1)
        l3 = np.max(m3) - np.min(m3)

        return [l1,l2,l3]
        
     
    #Plot triangulated surface
    def plotsurf(self,C=None):
        &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

            Parameters
            ----------
            C : (num_verts,3) int array, default is None
                An optional per-vertex labeling scheme to use.
        
            Returns
            -------
            A visualization of the mesh.
        &#34;&#34;&#34;

        if C is None:
            mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles)
        else:
            mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)

    def cplotsurf(self,C=-1):
        &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

            Parameters
            ----------
            C : (num_verts,3) int array, default is -1
                An optional per-vertex labeling scheme to use.
        
            Returns
            -------
            mesh : amaazetools.trimesh.mesh object
                A colored visualization of the mesh.
        &#34;&#34;&#34;

        if C.any == -1: #if no C given
            C = np.ones((len(x),1))
            
        n = len(np.unique(C))
        C = C.astype(int)
        if n&gt;20:
            mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)
        else:
            col = (np.arange(1,n+1)) / n
            colors = col[C-1]
            mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=colors)
            
        return mesh
        
    #Write a ply file
    def to_ply(self,fname):
        &#34;&#34;&#34; Writes the mesh to a .ply file.

            Parameters
            ----------
            fname : str
                The name of the .ply file to write the mesh to.
        &#34;&#34;&#34;

        f = open(fname,&#34;w&#34;)

        #Write header
        f.write(&#39;ply\n&#39;)
        f.write(&#39;format binary_little_endian 1.0\n&#39;)
        f.write(&#39;element vertex %u\n&#39;%self.num_verts())
        f.write(&#39;property double x\n&#39;)
        f.write(&#39;property double y\n&#39;)
        f.write(&#39;property double z\n&#39;)
        f.write(&#39;element face %u\n&#39;%self.num_tri())
        f.write(&#39;property list int int vertex_indices\n&#39;)
        f.write(&#39;end_header\n&#39;)
        f.close()

        f = open(fname,&#34;ab&#34;)

        #write vertices
        f.write(self.points.astype(&#39;float64&#39;).tobytes())

        #write faces
        T = np.hstack((np.ones((self.num_tri(),1))*3,self.triangles)).astype(int)
        f.write(T.astype(&#39;int32&#39;).tobytes())

        #close file
        f.close()
       
    #Write a ply file
    def write_color_ply(self,color,fname):
        &#34;&#34;&#34; Writes the colored mesh to a .ply file.

            Parameters
            ----------
            color : (num,verts,3) float array
                An array of color data for each point.
            fname : str
                The name of the .ply file to write the colored mesh to.
        &#34;&#34;&#34;

        f = open(fname,&#34;w&#34;)

        #Write header
        f.write(&#39;ply\n&#39;)
        f.write(&#39;format binary_little_endian 1.0\n&#39;)
        f.write(&#39;element vertex %u\n&#39;%self.num_verts())
        f.write(&#39;property double x\n&#39;)
        f.write(&#39;property double y\n&#39;)
        f.write(&#39;property double z\n&#39;)
        f.write(&#39;property uchar red\n&#39;)
        f.write(&#39;property uchar green\n&#39;)
        f.write(&#39;property uchar blue\n&#39;)
        f.write(&#39;element face %u\n&#39;%self.num_tri())
        f.write(&#39;property list int int vertex_indices\n&#39;)
        f.write(&#39;end_header\n&#39;)
        f.close()

        f = open(fname,&#34;ab&#34;)

        #write vertices
        for i in range(self.num_verts()):
            f.write(P[i,:].astype(&#39;float64&#39;).tobytes())
            f.write(color[i,:].astype(&#39;uint8&#39;).tobytes())

        #write faces
        T = np.hstack((np.ones((self.num_tri(),1))*3,T)).astype(int)
        f.write(T.astype(&#39;int32&#39;).tobytes())

        #close file
        f.close()

    def to_gif(self,fname,color = [],duration=7,fps=20,size=750,histeq = True):
        &#34;&#34;&#34; Writes rotating gif

            Parameters
            ----------
            fname : str
                gif filename
            color : (1,3) or (num_verts,1) or (num_verts,2) float array, default is (.7,.7,.7)
                3-tuple 0 to 1 RGB for single color over surface OR array the length of Self.Points for interpolation (1D or 2D - if 2D, uses first column).
            duration : float, default is 7
                length of gif in seconds
            fps: float, default is 20
                frames per second
            size: float, default is 750
                size of gif images
            histeq : boolean, default is True
                Performs histogram equalization on scalar color array; else should normalize prior to input.
        &#34;&#34;&#34;
    
        from skimage import exposure
        
        #Make copy of points
        X = self.points.copy()
        
        if np.shape(color)[0] == np.shape(X)[0]: #scalars for plot
            opt = 2
            if histeq:
                color = color - np.amin(color)
                color = 1-exposure.equalize_hist(color/np.max(color),nbins=1000)
                
            if np.shape(np.shape(color))[0]&gt;1: #handle input
                color = color[:,0]
        elif max(np.shape(color)) == 3: #single rgb color
            opt = 1
        else : #not input - default to single color
            color = (0.7,0.7,0.7)
            opt = 1
        
        #PCA
        Mean = np.mean(X,axis=0)
        cov_matrix = (X-Mean).T@(X-Mean)
        Vals, P = np.linalg.eig(cov_matrix)
        idx = Vals.argsort()
        i = idx[2]
        idx[2] = idx[1]
        idx[1] = i
        Vals = Vals[idx]
        P = P[:,idx]
        P[:,2] = np.cross(P[:,0],P[:,1])

        #Rotate fragment
        X = X@P

        #Plot mesh
        f = mlab.figure(bgcolor=(1,1,1),size=(size,size))
        if opt == 1:
            mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,color=color)
        else :
            mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,scalars=color)

        #Function that makes gif animation
        def make_frame(t):
            mlab.view(0,180+t/duration*360)
            GUI().process_events()
            return mlab.screenshot(antialiased=True)

        animation = mpy.VideoClip(make_frame, duration=duration)
        animation.write_gif(fname, fps=fps)
        mlab.close(f)

    def svi(self,r,ID=None):
        &#34;&#34;&#34; Computes spherical volume invariant.
        
            Parameters
            ----------
            r : (k,1) float array
                List of radii to use.
            ID : (n,1) boolean array, default is None
                Spherical volume is only computed at points with True indices. 
        
            Returns
            -------
            S : (n,1) float array
                The volumes corresponding to each point.
            G : (n,1) float array
                The  gamma values corresponding to each point.
        &#34;&#34;&#34;
   
        return svi.svi(self.points,self.triangles,r,ID=ID)

    def svipca(self,r):
        &#34;&#34;&#34; Computes SVIPCA

            Parameters
            ----------
            r : (k,1) float array
                List of radii to use.

            Returns
            -------
            S : (n,1) float array
                The volumes corresponding to each point.
            K1 : (n,1) float array
                The first principle curvature for each point.
            K2 : (n,1) float array
                The second principle curvature for each point.
            V1 : (n,3) float array
                The first principal direction for each point. 
            V2 : (n,3) float array
                The second principal direction for each point.
            V3 : (n,3) float array
                The third principal direction for each point.
        &#34;&#34;&#34;

        return svi.svipca(self.points,self.triangles,r)

    def edge_graph_detect(self,**kwargs):
        &#34;&#34;&#34; Detects edges using SVIPCA and principal direction metric.
            
            Parameters
            ----------
            M : amaazetools.trimesh.mesh object
            k1 : float, optional
                A constant on the minimum of the inverse of principal curvatures.
            k2 : float, optional
                A constant on the mean volume.
            VOL : (n,1) float array, optional
                Spherical volume corresponding to each point in the mesh.
            K1 : (n,1) float array, optional
                First principal curvature of each point.
            K2 : (n,1) float array, optional
                Second principal curvature of each point.
            V1 : (n,3) float array, optional
                First principal direction for each point.
            V2 : (n,3) float array, optional
                Second principal direction for each point.
            rvol : float, optional
                Radius to use for svipca.
            rpdir : float, optional
                Radius to use for the principal direction metric.

            Returns
            -------
            Edges : (n,1) boolean array
                A true value corresponds to that index being an edge point.
        &#34;&#34;&#34;
        
        return edge_detection.edge_graph_detect(self,**kwargs)

    def graph_setup(self,n,r,p,seed=None):
        &#34;&#34;&#34; Creates the graph to use for poisson learning.

            Parameters
            ----------
            n : int
                The number of vertices to sample for the graph.
            r : float
                Radius for graph construction.
            p : float
                Weight matrix parameter.
            seed : int, default is None
                Optional seed for random number generator.
        
            Returns
            -------
            poisson_W_matrix : (n,n) scipy.sparse.lil_matrix
                Weight matrix describing similarities of normal vectors.
            poisson_J_matrix : (num_verts,n) scipy.sparse.lil_matrix
                Matrix with indices of nearest neighbors.
            poisson_node_idx : (num_verts,1) int array
                The indices of the closest point in the sample.
        &#34;&#34;&#34;

        rng = (
            np.random.default_rng(seed=seed)
            if seed is not None
            else np.random.default_rng()
        )

        if self.poisson_W_matrix is None or self.poisson_J_matrix is None or self.poisson_node_idx is None:

            v = self.vertex_normals()
            N = self.num_verts()
        
            #Random subsample
            ss_idx = np.matrix(rng.choice(self.points.shape[0],n,replace=False))
            y = np.squeeze(self.points[ss_idx,:])
            w = np.squeeze(v[ss_idx,:])

            xTree = spatial.cKDTree(self.points)
            nn_idx = xTree.query_ball_point(y, r)
            yTree = spatial.cKDTree(y)
            nodes_idx = yTree.query_ball_point(y, r)
        
            bn = np.zeros((n,3))
            J = sparse.lil_matrix((N,n))
            for i in range(n):
                vj = v[nn_idx[i],:]
                normal_diff = w[i] - vj
                weights = np.exp(-8 * np.sum(np.square(normal_diff),1,keepdims=True))
                bn[i] = np.sum(weights*vj,0) / np.sum(weights,0)
            
                #Set ith row of J
                normal_diff = bn[i]- vj
                weights = np.exp(-8 * np.sum(np.square(normal_diff),1))#,keepdims=True))
                J[nn_idx[i],i] = weights
            
            #Normalize rows of J
            RSM = sparse.spdiags((1 / np.sum(J,1)).ravel(),0,N,N)
            J = RSM @ J
        
            #Compute weight matrix W
            W = sparse.lil_matrix((n,n))
            for i in range(n):
                nj = bn[nodes_idx[i]]
                normal_diff = bn[i] - nj
                weights = np.exp(-32 * ((np.sqrt(np.sum(np.square(normal_diff),1)))/2)**p)
                W[i,nodes_idx[i]] = weights
        
            #Find nearest node to each vertex
            nbrs = NearestNeighbors(n_neighbors=1, algorithm=&#39;ball_tree&#39;).fit(y)
            instances, node_idx = nbrs.kneighbors(self.points)

            self.poisson_W_matrix = W
            self.poisson_J_matrix = J
            self.poisson_node_idx = node_idx
        
        return self.poisson_W_matrix, self.poisson_J_matrix, self.poisson_node_idx   

    def poisson_label(self,g,I,n=5000,r=0.5,p=1,s=None,graph_setup=False):
        &#34;&#34;&#34; Performs poisson learning on the mesh.

            Parameters
            ----------
            g : (k,1) int array
                Labels to assign to vertices.
            I : (k,1) int array
                User-selected vertices.
            n : int, default is 5000
                The number of nodes to sample.
            r : float, default is 0.5
                The radius for nearest neighbor search.
            p : float, default is 1.0
                The weight matrix parameter.
            s : default is None
                Weights for fine-tuning Poisson learning.
            graph_setup : boolean, default is False
                Force graph construction if True.
        
            Returns
            -------
            L : (num_verts,1) int array
                Poisson labelling of each point in mesh.
        &#34;&#34;&#34;
    
        if graph_setup or (self.poisson_node_idx is None):
            self.graph_setup(n,r,p)

        I = self.poisson_node_idx[I]
        W = self.poisson_W_matrix
        u = poisson_learning(W,g,I)
        J = self.poisson_J_matrix

        if s is None:
            L = np.argmax(J@u,1)
        else:
            k = np.max(g)+1  #Number of classes, assuming 0,1,2,3,..,k-1 are  used
            L = np.argmax(J@(u*s[:k]),1)
        L = canonical_labels(L)

        self.poisson_labels = L

        return L
    
    #Virtual goniometer
    #Input:
    #   point = location to take measurement (index, or (x,y,z) coordinates)
    #   P = nx3 numpy array of vertices of mesh
    #   T = mx3 numpy array of triangles in mesh
    #Output:
    #   theta = Angle
    #   n1,n2 = Normal vectors between two patches (theta=angle(n1,n2))
    #   C = Clusters (C=1 and C=2 are the two detected clusters, C=0 indicates outside of patch)
    #   E (optional) = array of indices of edge points
    def virtual_goniometer(self,point,r,k=7,SegParam=2,return_edge_points=False,number_edge_points=None):
        &#34;&#34;&#34; Runs a virtual goniometer to measure break angles.

            Parameters
            ----------

            point : (1,3) float array or int
                A mesh vertex, as a coordinate or index.
            r : float
                Radius used to build patch.
            k: int, default is 7
                Number of nearest neighbors to use.
            SegParam : float, default is 2
                Segmentation parameter that encourages splitting patch in half as it increases in size.
            return_edge_points : boolean, default is False
                If True, return edge points in patch.
            number_edge_points : boolean, default is None
                Specifies how many edge points to return.
        
            Returns
            -------
            theta : float
                The break angle.
            n1 : (3,) float array
                Contains the normal vector of one break surface.
            n2 : (3,) float array
                Contains the normal vector of the other surface.
            C : (num_verts,) int array
                Contains the cluster (1 or 2) of each point in the patch; points not in the patch are assigned a 0.
            E : (number_edge_points,1) int array, not returned by default
                List of  edge point indices.
        &#34;&#34;&#34;

        patch_ind = self.geodesic_patch(point,r,k=k)
        patch = self.points[patch_ind,:]
        normals = self.vertex_normals()[patch_ind,:]
        theta,n1,n2,C_local = __virtual_goniometer__(patch,normals,SegParam=SegParam)

        C = np.zeros(self.num_verts())
        C[patch_ind] = C_local


        if return_edge_points:
            E = self.edge_points(C_local,k=k,number=number_edge_points)
            E = patch_ind[E]
            return theta,n1,n2,C,E
        else:
            return theta,n1,n2,C

#Virtual goniometer (internal function)
#Input:
#   P = nx3 numpy array of vertices of points in patch
#   N = nx3 array of vertex normals
#   Can also use N as face normals, and P as face centroids
#Output:
#   theta = Angle
#   n1,n2 = Normal vectors between two patches (theta=angle(n1,n2))
#   C = Clusters (C=1 and C=2 are the two detected clusters)
def __virtual_goniometer__(P,N,SegParam=2,UsePCA=True,UsePower=False):
    &#34;&#34;&#34; Internal function used within class method virtual_goniometer to measure break angles.

        Parameters
        ----------
        P : (n,3) float array
            Vertices in a patch.
        N : (n,3) float array
            Vertex normal vectors.
        SegParam : float, default is 2
            Segmentation parameter that encourages splitting patch in half as it increases in size.
        UsePCA: boolean, default is True
            Uses PCA instead of averaged surface normals if True. 
        UsePower : boolean, default is False
            Uses the power method when doing PCA if True.
    
        Returns
        -------
        theta : float
            The break angle.
        n1 : (3,) float array
            Contains the normal vector of one break surface.
        n2 : (3,) float array
            Contains the normal vector of the other surface.
        C : (num_verts,) int array
            Contains the cluster (1 or 2) of each point in the patch; points not in the patch are assigned a 0.
    &#34;&#34;&#34;

    n = P.shape[0]

    if UsePower:
        N1 = pca_smallest_eig_powermethod(N,center=False)
        N1 = np.reshape(N1,(3,))
    else:
        N1 = pca_smallest_eig(N,center=False)

    N2 = np.sum(N,axis=0)
    v = np.cross(N1,N2)
    v = v/np.linalg.norm(v)

    m = np.mean(P,axis=0)
    dist = np.sqrt(np.sum((P - m)**2,axis=1))
    i = np.argmin(dist)
    radius = np.max(dist)
    D = (P - P[i,:])/radius

    #The SegParam=2 is just hand tuned. Larger SegParam encourages the clustering to split the patch in half
    #SegParam=0 is the previous version of the virtual goniometer
    x = np.sum(v*N,axis=1) + SegParam*np.sum(v*D,axis=1)

    #Clustering
    w,m = withiness(x)
    C = np.zeros(n,)
    C[x&gt;m] = 1
    C[x&lt;=m] = 2

    if UsePCA:

        P1 = P[C==1,:]
        P2 = P[C==2,:]
        if UsePower:
            n1 = pca_smallest_eig_powermethod(P1)
            n2 = pca_smallest_eig_powermethod(P2)
        else:
            n1 = pca_smallest_eig(P1)
            n2 = pca_smallest_eig(P2)

        s1 = np.mean(N[C==1,:],axis=0)
        if np.dot(n1,s1) &lt; 0:
            n1 = -n1

        s2 = np.mean(N[C==2,:],axis=0)
        if np.dot(n2,s2) &lt; 0:
            n2 = -n2
    else: #Use average of surface normals

        n1 = np.average(N[C==1,:],axis=0)
        n1 = n1/np.linalg.norm(n1)
        n2 = np.average(N[C==2,:],axis=0)
        n2 = n2/np.linalg.norm(n2)
        
    #Angle between
    theta = 180-np.arccos(np.dot(n1,n2))*180/np.pi
    return theta,n1,n2,C
    
def conjgrad(A,b,x,T,tol):
    &#34;&#34;&#34; Performs conjugate gradient descent.

        Parameters
        ----------
        A : matrix multiplying x
        b : vector equal to product of A and x
        x : initial estimate for x 
        T : int
            Number of time steps allowed.
        Tol : float
            Desired convergence tolerance of result.
        
        Returns
        -------
        x : calculated value for x
        i : int
            Number of iterations required for convergence.
    &#34;&#34;&#34;
        
    r = b - A@x
    p = r
    rsold = np.sum(r * r,0)
    for i in range(int(T)):
        Ap = A@p
        alpha = rsold / np.sum(p*Ap,0)
        x = x + alpha*p
        r = r - alpha*Ap
        rsnew = np.sum(r*r,0)
        if np.sqrt(np.sum(rsnew)) &lt; tol:
            break
        p = r + (rsnew / rsold) * p
        rsold = rsnew
    return x,i

def poisson_learning(W,g,I):
    &#34;&#34;&#34; Performs poisson learning.

        Parameters
        ----------
        W : (n,n) float array
            Weight matrix of subsampled graph of mesh.
        g : (m,1) int array
            Labels to assign to selected vertices.
        I : (m,1) int array
            Indices of user-selected vertices.
        
        Returns
        -------
        u : (num_verts,1) int array
            Poisson labels for each vertex in the mesh.
    &#34;&#34;&#34;
        
    k = len(np.unique(g))
    n = W.shape[0]
    m = len(I)
    I = I - 1
    g = g.T - 1

    F = np.zeros((n,k))
    for i in range(m):
        F[I[i],g[i]] = 1
    c = np.ones((1,n)) @ F / len(g)
    F[I] -= c
    
    deg = np.sum(W,1)
    D = sparse.spdiags(deg.T,0,n,n)
    L = D-W #Unnormalized graph laplacian matrix
    
    #Preconditioning
    Dinv2 = sparse.spdiags(np.power(np.sum(W,1),-1/2).T,0,n,n) 
    Lnorm = Dinv2 @ L @ Dinv2
    F = Dinv2 @ F
    
    #Conjugate Gradient Solver
    u,i = conjgrad(Lnorm,F,np.zeros((n,k)),1e5, np.sqrt(n)*1e-10)
    
    #Undo preconditioning
    u = Dinv2 @ u
    return u

def canonical_labels(u):
    &#34;&#34;&#34; Reorders a label vector into canonical order.

        Parameters
        ----------
        u : (num_verts,1) int array
            A label vector.
        
        Returns
        -------
        u : (num_verts,1) int array
            A reodered label vector.
    &#34;&#34;&#34;
        
    n = len(u)
    k = len(np.unique(u))
    label_set = np.zeros((k,1))
    label = 0
    
    for i in range(n):
        if u[i] &gt; label:
            label += 1
            l = u[i]
            I = u == label
            J = u == l
            u[I] = l
            u[J] = label
    return u</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="amaazetools.trimesh.canonical_labels"><code class="name flex">
<span>def <span class="ident">canonical_labels</span></span>(<span>u)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorders a label vector into canonical order.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>A label vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>A reodered label vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canonical_labels(u):
    &#34;&#34;&#34; Reorders a label vector into canonical order.

        Parameters
        ----------
        u : (num_verts,1) int array
            A label vector.
        
        Returns
        -------
        u : (num_verts,1) int array
            A reodered label vector.
    &#34;&#34;&#34;
        
    n = len(u)
    k = len(np.unique(u))
    label_set = np.zeros((k,1))
    label = 0
    
    for i in range(n):
        if u[i] &gt; label:
            label += 1
            l = u[i]
            I = u == label
            J = u == l
            u[I] = l
            u[J] = label
    return u</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.conjgrad"><code class="name flex">
<span>def <span class="ident">conjgrad</span></span>(<span>A, b, x, T, tol)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs conjugate gradient descent.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>matrix multiplying x</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>vector equal to product</code> of <code>A and x</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>initial estimate for x </code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps allowed.</dd>
<dt><strong><code>Tol</code></strong> :&ensp;<code>float</code></dt>
<dd>Desired convergence tolerance of result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>calculated value for x</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations required for convergence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conjgrad(A,b,x,T,tol):
    &#34;&#34;&#34; Performs conjugate gradient descent.

        Parameters
        ----------
        A : matrix multiplying x
        b : vector equal to product of A and x
        x : initial estimate for x 
        T : int
            Number of time steps allowed.
        Tol : float
            Desired convergence tolerance of result.
        
        Returns
        -------
        x : calculated value for x
        i : int
            Number of iterations required for convergence.
    &#34;&#34;&#34;
        
    r = b - A@x
    p = r
    rsold = np.sum(r * r,0)
    for i in range(int(T)):
        Ap = A@p
        alpha = rsold / np.sum(p*Ap,0)
        x = x + alpha*p
        r = r - alpha*Ap
        rsnew = np.sum(r*r,0)
        if np.sqrt(np.sum(rsnew)) &lt; tol:
            break
        p = r + (rsnew / rsold) * p
        rsold = rsnew
    return x,i</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.load_ply"><code class="name flex">
<span>def <span class="ident">load_ply</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a file path or url and creates a mesh object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>URL or file path at which to access .ply file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A mesh object generated from a .ply file found at the file path location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ply(path):
    &#34;&#34;&#34; Loads a file path or url and creates a mesh object.

        Parameters
        ----------
        path : str
            URL or file path at which to access .ply file.
    
        Returns
        -------
        A mesh object generated from a .ply file found at the file path location.
    &#34;&#34;&#34;

    try:
      url.urlopen(path)
      is_url = True
    except:
      is_url = False

    if is_url:
      fname = path.rsplit(&#39;/&#39;, 1)[-1]
      url.urlretrieve(path,fname)
    else:
      fname = path

    points,triangles = read_ply(fname)
    return mesh(points,triangles)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.pca"><code class="name flex">
<span>def <span class="ident">pca</span></span>(<span>P)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes principal component analysis (PCA) on a point cloud P.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,d) float array</code></dt>
<dd>A point cloud.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>vals</code></strong> :&ensp;<code>(d,) float arrayy</code></dt>
<dd>The variances among each principal component.</dd>
<dt><strong><code>vecs</code></strong> :&ensp;<code>(d,d) float array</code></dt>
<dd>The principal component vectors.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>boolean</code></dt>
<dd>True when the first principal component direction is positively oriented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pca(P):
    &#34;&#34;&#34; Computes principal component analysis (PCA) on a point cloud P.

        Parameters
        ----------
        P : (n,d) float array
            A point cloud.
        
        Returns
        -------
        vals : (d,) float arrayy
            The variances among each principal component.
        vecs : (d,d) float array
            The principal component vectors.
        sign : boolean
            True when the first principal component direction is positively oriented.
    &#34;&#34;&#34;
        
    P = P - np.mean(P,axis=0)
    vals,vecs = np.linalg.eig(P.T@P)
    sign = np.max(vecs[0,:]) &gt; 0

    return vals,vecs,sign</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.pca_smallest_eig"><code class="name flex">
<span>def <span class="ident">pca_smallest_eig</span></span>(<span>X, center=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the last principal component of a point cloud X.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>boolean</code>, default <code>is True</code></dt>
<dd>Data is centered if True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A float array of size (3,) containing the last principal component vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pca_smallest_eig(X,center=True):
    &#34;&#34;&#34; Computes the last principal component of a point cloud X.

        Parameters
        ----------
        X : (n,3) float array
            A point cloud.
        center : boolean, default is True
            Data is centered if True.
        
        Returns
        -------
        A float array of size (3,) containing the last principal component vector.
    &#34;&#34;&#34;

    if center:
        m = np.mean(X,axis=0)
        cov = np.transpose(X-m)@(X-m)
    else:
        cov = np.transpose(X)@X
    w,v = np.linalg.eig(cov)
    i = np.argmin(w)
    return v[:,i]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.pca_smallest_eig_powermethod"><code class="name flex">
<span>def <span class="ident">pca_smallest_eig_powermethod</span></span>(<span>X, center=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the last principal component of a point cloud X using the power method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>boolean</code>, default <code>is True</code></dt>
<dd>Data is centered if True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A float array of size (3,) containing the last principal component vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pca_smallest_eig_powermethod(X,center=True):
    &#34;&#34;&#34; Computes the last principal component of a point cloud X using the power method.

        Parameters
        ----------
        X : (n,3) float array
            A point cloud.
        center : boolean, default is True
            Data is centered if True.
        
        Returns
        -------
        A float array of size (3,) containing the last principal component vector.
    &#34;&#34;&#34;

    if center:
        m = np.mean(X,axis=0)
        cov = np.transpose(X-m)@(X-m)/X.shape[0]
    else:
        cov = np.transpose(X)@X/X.shape[0]
    lmax,v = power_method(cov)
    w,v = np.linalg.eig(cov)
    l,v = power_method(cov - (lmax+1)*np.eye(3))
    return v.flatten()</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.poisson_learning"><code class="name flex">
<span>def <span class="ident">poisson_learning</span></span>(<span>W, g, I)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs poisson learning.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>W</code></strong> :&ensp;<code>(n,n) float array</code></dt>
<dd>Weight matrix of subsampled graph of mesh.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>(m,1) int array</code></dt>
<dd>Labels to assign to selected vertices.</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>(m,1) int array</code></dt>
<dd>Indices of user-selected vertices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>Poisson labels for each vertex in the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poisson_learning(W,g,I):
    &#34;&#34;&#34; Performs poisson learning.

        Parameters
        ----------
        W : (n,n) float array
            Weight matrix of subsampled graph of mesh.
        g : (m,1) int array
            Labels to assign to selected vertices.
        I : (m,1) int array
            Indices of user-selected vertices.
        
        Returns
        -------
        u : (num_verts,1) int array
            Poisson labels for each vertex in the mesh.
    &#34;&#34;&#34;
        
    k = len(np.unique(g))
    n = W.shape[0]
    m = len(I)
    I = I - 1
    g = g.T - 1

    F = np.zeros((n,k))
    for i in range(m):
        F[I[i],g[i]] = 1
    c = np.ones((1,n)) @ F / len(g)
    F[I] -= c
    
    deg = np.sum(W,1)
    D = sparse.spdiags(deg.T,0,n,n)
    L = D-W #Unnormalized graph laplacian matrix
    
    #Preconditioning
    Dinv2 = sparse.spdiags(np.power(np.sum(W,1),-1/2).T,0,n,n) 
    Lnorm = Dinv2 @ L @ Dinv2
    F = Dinv2 @ F
    
    #Conjugate Gradient Solver
    u,i = conjgrad(Lnorm,F,np.zeros((n,k)),1e5, np.sqrt(n)*1e-10)
    
    #Undo preconditioning
    u = Dinv2 @ u
    return u</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.power_method"><code class="name flex">
<span>def <span class="ident">power_method</span></span>(<span>A, tol=1e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the smallest (in absolute value) eigenvalue and its corresponding eigenvector using the power method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>(n,n) float array</code></dt>
<dd>A square matrix that one wishes to find the smallest (in absolute value) eigenvalue and corresponding eigenvector of.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, default <code>is 1e-12</code></dt>
<dd>The desired tolerance threshold after which to stop iteration.</dd>
</dl>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>The smallest (in absolute value) eigenvalue of A.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>Array containing the eigenvector corresponding to the smallest (in absolute value) eigenvalue of A.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_method(A,tol=1e-12):
    &#34;&#34;&#34; Computes the smallest (in absolute value) eigenvalue and its corresponding eigenvector using the power method.

        Parameters
        ----------
        A : (n,n) float array
            A square matrix that one wishes to find the smallest (in absolute value) eigenvalue and corresponding eigenvector of.
        tol : float, default is 1e-12
            The desired tolerance threshold after which to stop iteration.
        
        Parameters
        ----------
        l : float
            The smallest (in absolute value) eigenvalue of A.
        x : (n,1) float array
            Array containing the eigenvector corresponding to the smallest (in absolute value) eigenvalue of A.
    &#34;&#34;&#34;

    n = A.shape[0]
    x = np.random.rand(n,1)
    err = 1
    i = 1
    while err &gt; tol:
        x = A@x
        x = x/np.linalg.norm(x)
        l = np.transpose(x)@A@x
        err = np.linalg.norm(A@x - l*x)
        i = i+1
    return l,x</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.read_ply"><code class="name flex">
<span>def <span class="ident">read_ply</span></span>(<span>fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the vertex and triangle data stored in a .ply file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file to read from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(num_verts,3) float array</code></dt>
<dd>The coordinates of the vertices of the mesh.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>(num_tri,3) int array</code></dt>
<dd>The indices of the triangles of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_ply(fname):
    &#34;&#34;&#34; Reads the vertex and triangle data stored in a .ply file.

        Parameters
        ----------
        fname: str
            Name of the file to read from.
        
        Returns
        -------
        P : (num_verts,3) float array
            The coordinates of the vertices of the mesh.
        T : (num_tri,3) int array
            The indices of the triangles of the mesh.
    &#34;&#34;&#34;

    plydata = PlyData.read(fname)

    #Convert data formats
    try:
        tri_data = plydata[&#39;face&#39;].data[&#39;vertex_indices&#39;]
    except:
        tri_data = plydata[&#39;face&#39;].data[&#39;vertex_index&#39;]

    T = np.vstack(tri_data)
    x = plydata[&#39;vertex&#39;].data[&#39;x&#39;]
    y = plydata[&#39;vertex&#39;].data[&#39;y&#39;]
    z = plydata[&#39;vertex&#39;].data[&#39;z&#39;]
    P = np.vstack((x,y,z))
    P = P.transpose()

    return P,T.astype(int)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.weighted_pca"><code class="name flex">
<span>def <span class="ident">weighted_pca</span></span>(<span>P, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes weighted principal component analysis (PCA) on a point cloud P.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>(n,d) float array</code></dt>
<dd>A point cloud.</dd>
<dt><strong><code>W</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>An array containing the weights of the points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>vals</code></strong> :&ensp;<code>(d,) float array</code></dt>
<dd>The variances among each principal component.</dd>
<dt><strong><code>vecs</code></strong> :&ensp;<code>(d,d) float array</code></dt>
<dd>The principal component vectors.</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>boolean</code></dt>
<dd>True when the first principal component direction is positively oriented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weighted_pca(P,W):
    &#34;&#34;&#34; Computes weighted principal component analysis (PCA) on a point cloud P.

        Parameters
        ----------
        P : (n,d) float array
            A point cloud.
        W : (n,1) float array
            An array containing the weights of the points.
        
        Returns
        -------
        vals : (d,) float array
            The variances among each principal component.
        vecs : (d,d) float array
            The principal component vectors.
        sign : boolean
            True when the first principal component direction is positively oriented.
    &#34;&#34;&#34;

    P = P - np.mean(W*P,axis=0)
    vals,vecs = np.linalg.eig(P.T@(W*P))
    sign = np.max(vecs[0,:]) &gt; 0

    return vals,vecs,sign</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.withiness"><code class="name flex">
<span>def <span class="ident">withiness</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes withiness (how well 1-D data clusters into two groups).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>A 1-D collection of data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>The withiness of the data.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>The point at which to split the data into 2 clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def withiness(x):
    &#34;&#34;&#34; Computes withiness (how well 1-D data clusters into two groups).

        Parameters
        ----------
        x : (n,1) float array
            A 1-D collection of data.
        
        Returns
        -------
        w : float
            The withiness of the data.
        m : float
            The point at which to split the data into 2 clusters.
    &#34;&#34;&#34;

    x = np.sort(x)
    sigma = np.std(x)
    n = x.shape[0]
    v = np.zeros(n-1,)
    for i in range(n-1):
        x1 = x[:(i+1)]
        x2 = x[(i+1):]
        m1 = np.mean(x1);
        m2 = np.mean(x2);
        v[i] = (np.sum((x1-m1)**2) + np.sum((x2-m2)**2))/(sigma**2*n);
    ind = np.argmin(v)
    m = x[ind]
    w = v[ind]
    return w,m</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="amaazetools.trimesh.mesh"><code class="flex name class">
<span>class <span class="ident">mesh</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh:

    def __init__(self,*args):
        self.points = args[0]
        self.triangles = args[1]
        self.unit_norms = None
        self.norms = None
        self.centers = None
        self.knn_I = None
        self.knn_J = None
        self.knn_D = None
        self.tri_vert_adj_I = None
        self.tri_vert_adj_J = None
        self.poisson_W_matrix = None
        self.poisson_J_matrix = None
        self.poisson_node_idx = None
        self.poisson_labels = None

    #Get number of vertices
    def num_verts(self):
        &#34;&#34;&#34; Computes number of vertices in the mesh.

            Returns
            -------
            The number of vertices in the mesh as an integer.
        &#34;&#34;&#34;

        return self.points.shape[0]

    #Get number of triangles
    def num_tri(self):
        &#34;&#34;&#34; Computes number of triangles in the mesh.

            Returns
            -------
            The number of triangles in the mesh as an integer.
        &#34;&#34;&#34;

        return self.triangles.shape[0]

    #Converts from (x,y,z) to index of closest point
    def get_index(self,point):
        &#34;&#34;&#34; Computes the index of a given point.

            Parameters
            ----------
            point : int or (1,3) float array
                A vertex in the mesh, specified by either an integer index or its coordinates.

            Returns
            -------
            The index of the given point as an integer.
        &#34;&#34;&#34;

        if type(point) in [np.int,np.int32,np.int64]:
            point_ind=point
        elif type(point) == np.ndarray and len(point)==3:
            point_ind = np.argmin(np.linalg.norm(self.points - point,axis=1))
        elif type(point) in [tuple,list] and len(point)==3:
            point_ind = np.argmin(np.linalg.norm(self.points - np.array(point),axis=1))
        else:
            sys.exit(&#34;&#39;point&#39; must be an integer index, or a length 3 list, tuple, or numpy ndarray (x,y,z)&#34;)
        return point_ind

    def edge_points(self,u,k=7,return_mask=False,number=None):
        &#34;&#34;&#34; Computes the edge points of the mesh.

            Parameters
            ----------
            u : (num_verts,1) int array
                Array of labels for each point.
            k : int, default is 7
                Number of nearest neighbors to use.
            return_mask : boolean, default is False
                If True, return edge_points as a (num,verts,) boolean array.
            number : int, default is None
                Max number of edge points to return.

            Returns
            -------
            An int array containing the edge point indices.
        &#34;&#34;&#34;

        if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
            self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
        I = self.knn_I[:,:k]
        J = self.knn_J[:,:k]
        D = self.knn_D[:,:k]
        W = gl.weight_matrix(I,J,D,k,f=lambda x : np.ones_like(x),symmetrize=False)
        d = gl.degrees(W)
        mask = d*u != W@u

        #Select a few points spaced out along edge
        if number is not None:
            edge_ind = np.arange(self.num_verts())[mask]
            edge_points = self.points[mask,:]
            num_edge_points = len(edge_points)

            #PCA
            mean = np.mean(edge_points,axis=0)
            cov = (edge_points-mean).T@(edge_points-mean)
            l,v = sparse.linalg.eigs(cov,k=1,which=&#39;LM&#39;)
            proj = (edge_points-mean)@v.real

            #Sort along princpal axis
            sort_ind = np.argsort(proj.flatten())
            dx = (num_edge_points-1)/(number-1)
            spaced_edge_ind = edge_ind[sort_ind[np.arange(0,num_edge_points,dx).astype(int)]]
            mask = np.zeros(self.num_verts(),dtype=bool)
            mask[spaced_edge_ind]=True

        if return_mask:
            return mask.astype(int)
        else: #return indices
            return np.arange(self.num_verts())[mask]

    def geodesic_patch(self,point,r,k=7,return_mask=False):
        &#34;&#34;&#34; Computes a geodesic patch around a specified point.

            Parameters
            ----------
            point : int or (1,3) float array
                A mesh vertex.
            r : float
                Radius used to build patch.
            k : int, default is 7
                Number of nearest neighbors to use.
            return_mask : boolean, default is False
                If True, return the patch as a (num,verts,) boolean array

            Returns
            -------
            An int array containing the patch point indices.
        &#34;&#34;&#34;

        if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
            self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
        I = self.knn_I[:,:k]
        J = self.knn_J[:,:k]
        D = self.knn_D[:,:k]
        W = gl.dist_matrix(I,J,D,k)

        point_ind = self.get_index(point)
        dist = gl.cDijkstra(W,np.array([point_ind]),np.array([0]))
        mask = dist &lt; r

        if return_mask:
            return mask.astype(int)
        else: #return indices
            return np.arange(self.num_verts())[mask]

    #vertex-triangle adjacencey matrix
    #Returns num_verts x num_tri sparse matrix F with F_ij = 1 if vertex i belongs to triangle j
    #If normalize=True, then each row is divided by the number of adjacent triangles,
    #so F can be used to interplate from triangles to vertices
    def tri_vert_adj(self,normalize=False):
        &#34;&#34;&#34; Computes a sparse vertex-triangle adjacency matrix.
       
            Parameters
            ----------
            normalize : boolean, default is False
                If True, each row is divided by the number of adjacent triangles.

            Returns
            -------
            F : (num_verts,num_tri) boolean array
                Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.
        &#34;&#34;&#34;

        num_verts = self.num_verts()
        ind = np.arange(self.num_tri())

        if np.any(self.tri_vert_adj_I) is None or np.any(self.tri_vert_adj_J) is None:
            self.tri_vert_adj_I = np.hstack((self.triangles[:,0],self.triangles[:,1],self.triangles[:,2]))
            self.tri_vert_adj_J = np.hstack((ind,ind,ind))
        I = self.tri_vert_adj_I
        J = self.tri_vert_adj_J
        F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(self.num_verts(),self.num_tri())).tocsr()

        if normalize:
            num_adj_tri = F@np.ones(self.num_tri())
            F = sparse.spdiags(1/num_adj_tri,0,self.num_verts(),self.num_verts())@F

        return F

    #Returns unit normal vectors to vertices (averaging adjacent faces and normalizing)
    def vertex_normals(self):
        &#34;&#34;&#34; Computes normal vectors to vertices.
        
            Returns
            -------
            A (num_verts,3) float array containing the vertex normal vectors.
        &#34;&#34;&#34;

        if self.unit_norms is None:
            self.face_normals()
        fn = self.unit_norms
        F = self.tri_vert_adj()
        vn = F@fn
        norms = np.linalg.norm(vn,axis=1)
        norms[norms==0] = 1

        return vn/norms[:,np.newaxis]
                  
    #Returns unit normal vectors
    def face_normals(self,normalize=True):
        &#34;&#34;&#34; Computes normal vectors to triangles (faces).
        
            Parameters
            ----------
            normalize: boolean, default is True
                Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.
        
            Returns
            -------
            N : (num_tri,3) float array
                Array containing the face normal vectors.
        &#34;&#34;&#34;

        P1 = self.points[self.triangles[:,0],:]
        P2 = self.points[self.triangles[:,1],:]
        P3 = self.points[self.triangles[:,2],:]

        N = np.cross(P2-P1,P3-P1)
        if normalize:
            N = (N.T/np.linalg.norm(N,axis=1)).T
            self.unit_norms = N
            return N
        else:
          self.norms = N
          return N
          
    def flip_normals(self):
        &#34;&#34;&#34; Reverses the orientation of all normal vectors in the mesh
        &#34;&#34;&#34;

        self.Triangles = self.Triangles[:,::-1]

    #Areas of all triangles in mesh
    def tri_areas(self):
        &#34;&#34;&#34; Computes areas of all triangles in the mesh.
        
            Returns
            -------
            A (num_tri,) float array containing the areas of each triangle (face).
        &#34;&#34;&#34;

        if self.norms is None:
            self.face_normals(False)
        return np.linalg.norm(self.norms,axis=1)/2

    #Surface area of mesh
    def surf_area(self):
        &#34;&#34;&#34; Computes surface area of the mesh.
        
            Returns
            -------
            The surface area of the entire mesh as a float.
        &#34;&#34;&#34;

        return np.sum(self.tri_areas())
       
    #Centers of each face
    def face_centers(self):
        &#34;&#34;&#34; Computes coordinates of the center of each triangle (face).
        
            Returns
            -------
            A (num_tri,3) float array containing the coordinates of the face centers.
        &#34;&#34;&#34;

        P1 = self.points[self.triangles[:,0],:]
        P2 = self.points[self.triangles[:,1],:]
        P3 = self.points[self.triangles[:,2],:]

        result = (P1 + P2 + P3)/3
        self.centers = result
        return result
       
    #Volume enclosed by mesh
    def volume(self):
        &#34;&#34;&#34; Computes the volume of the mesh.
        
            Returns
            -------
            The volume of the mesh as a float.
        &#34;&#34;&#34;

        if self.centers is None:
            self.face_centers()
        X = self.centers
        X = X - np.mean(X,axis=0)
        if self.norms is None:
            self.face_normals(False)
        return np.sum(X*self.norms)/6
   
    def bbox(self):
        &#34;&#34;&#34; Computes the bounding box of the mesh.
        
            Returns
            -------
            A (3,) float array containing the dimensions of the bounding box.
        &#34;&#34;&#34;

        if self.centers is None:
            self.face_centers()
        X = self.centers
        n = X.shape[0]
        A = self.tri_areas()

        W = sparse.spdiags(A**2,0,n,n)
        vals,vecs = weighted_pca(X,W)

        vecs = vecs.T
        X = X - np.mean(W*X,axis=0)
        m1 = np.sum(X*vecs[0,:],axis=1)
        l1 = np.max(m1) - np.min(m1)
        m2 = np.sum(X*vecs[1,:],axis=1)
        l2 = np.max(m2) - np.min(m2)
        m3 = np.sum(X*vecs[2,:],axis=1)
        l3 = np.max(m3) - np.min(m3)

        return [l1,l2,l3]
        
     
    #Plot triangulated surface
    def plotsurf(self,C=None):
        &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

            Parameters
            ----------
            C : (num_verts,3) int array, default is None
                An optional per-vertex labeling scheme to use.
        
            Returns
            -------
            A visualization of the mesh.
        &#34;&#34;&#34;

        if C is None:
            mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles)
        else:
            mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)

    def cplotsurf(self,C=-1):
        &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

            Parameters
            ----------
            C : (num_verts,3) int array, default is -1
                An optional per-vertex labeling scheme to use.
        
            Returns
            -------
            mesh : amaazetools.trimesh.mesh object
                A colored visualization of the mesh.
        &#34;&#34;&#34;

        if C.any == -1: #if no C given
            C = np.ones((len(x),1))
            
        n = len(np.unique(C))
        C = C.astype(int)
        if n&gt;20:
            mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)
        else:
            col = (np.arange(1,n+1)) / n
            colors = col[C-1]
            mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=colors)
            
        return mesh
        
    #Write a ply file
    def to_ply(self,fname):
        &#34;&#34;&#34; Writes the mesh to a .ply file.

            Parameters
            ----------
            fname : str
                The name of the .ply file to write the mesh to.
        &#34;&#34;&#34;

        f = open(fname,&#34;w&#34;)

        #Write header
        f.write(&#39;ply\n&#39;)
        f.write(&#39;format binary_little_endian 1.0\n&#39;)
        f.write(&#39;element vertex %u\n&#39;%self.num_verts())
        f.write(&#39;property double x\n&#39;)
        f.write(&#39;property double y\n&#39;)
        f.write(&#39;property double z\n&#39;)
        f.write(&#39;element face %u\n&#39;%self.num_tri())
        f.write(&#39;property list int int vertex_indices\n&#39;)
        f.write(&#39;end_header\n&#39;)
        f.close()

        f = open(fname,&#34;ab&#34;)

        #write vertices
        f.write(self.points.astype(&#39;float64&#39;).tobytes())

        #write faces
        T = np.hstack((np.ones((self.num_tri(),1))*3,self.triangles)).astype(int)
        f.write(T.astype(&#39;int32&#39;).tobytes())

        #close file
        f.close()
       
    #Write a ply file
    def write_color_ply(self,color,fname):
        &#34;&#34;&#34; Writes the colored mesh to a .ply file.

            Parameters
            ----------
            color : (num,verts,3) float array
                An array of color data for each point.
            fname : str
                The name of the .ply file to write the colored mesh to.
        &#34;&#34;&#34;

        f = open(fname,&#34;w&#34;)

        #Write header
        f.write(&#39;ply\n&#39;)
        f.write(&#39;format binary_little_endian 1.0\n&#39;)
        f.write(&#39;element vertex %u\n&#39;%self.num_verts())
        f.write(&#39;property double x\n&#39;)
        f.write(&#39;property double y\n&#39;)
        f.write(&#39;property double z\n&#39;)
        f.write(&#39;property uchar red\n&#39;)
        f.write(&#39;property uchar green\n&#39;)
        f.write(&#39;property uchar blue\n&#39;)
        f.write(&#39;element face %u\n&#39;%self.num_tri())
        f.write(&#39;property list int int vertex_indices\n&#39;)
        f.write(&#39;end_header\n&#39;)
        f.close()

        f = open(fname,&#34;ab&#34;)

        #write vertices
        for i in range(self.num_verts()):
            f.write(P[i,:].astype(&#39;float64&#39;).tobytes())
            f.write(color[i,:].astype(&#39;uint8&#39;).tobytes())

        #write faces
        T = np.hstack((np.ones((self.num_tri(),1))*3,T)).astype(int)
        f.write(T.astype(&#39;int32&#39;).tobytes())

        #close file
        f.close()

    def to_gif(self,fname,color = [],duration=7,fps=20,size=750,histeq = True):
        &#34;&#34;&#34; Writes rotating gif

            Parameters
            ----------
            fname : str
                gif filename
            color : (1,3) or (num_verts,1) or (num_verts,2) float array, default is (.7,.7,.7)
                3-tuple 0 to 1 RGB for single color over surface OR array the length of Self.Points for interpolation (1D or 2D - if 2D, uses first column).
            duration : float, default is 7
                length of gif in seconds
            fps: float, default is 20
                frames per second
            size: float, default is 750
                size of gif images
            histeq : boolean, default is True
                Performs histogram equalization on scalar color array; else should normalize prior to input.
        &#34;&#34;&#34;
    
        from skimage import exposure
        
        #Make copy of points
        X = self.points.copy()
        
        if np.shape(color)[0] == np.shape(X)[0]: #scalars for plot
            opt = 2
            if histeq:
                color = color - np.amin(color)
                color = 1-exposure.equalize_hist(color/np.max(color),nbins=1000)
                
            if np.shape(np.shape(color))[0]&gt;1: #handle input
                color = color[:,0]
        elif max(np.shape(color)) == 3: #single rgb color
            opt = 1
        else : #not input - default to single color
            color = (0.7,0.7,0.7)
            opt = 1
        
        #PCA
        Mean = np.mean(X,axis=0)
        cov_matrix = (X-Mean).T@(X-Mean)
        Vals, P = np.linalg.eig(cov_matrix)
        idx = Vals.argsort()
        i = idx[2]
        idx[2] = idx[1]
        idx[1] = i
        Vals = Vals[idx]
        P = P[:,idx]
        P[:,2] = np.cross(P[:,0],P[:,1])

        #Rotate fragment
        X = X@P

        #Plot mesh
        f = mlab.figure(bgcolor=(1,1,1),size=(size,size))
        if opt == 1:
            mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,color=color)
        else :
            mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,scalars=color)

        #Function that makes gif animation
        def make_frame(t):
            mlab.view(0,180+t/duration*360)
            GUI().process_events()
            return mlab.screenshot(antialiased=True)

        animation = mpy.VideoClip(make_frame, duration=duration)
        animation.write_gif(fname, fps=fps)
        mlab.close(f)

    def svi(self,r,ID=None):
        &#34;&#34;&#34; Computes spherical volume invariant.
        
            Parameters
            ----------
            r : (k,1) float array
                List of radii to use.
            ID : (n,1) boolean array, default is None
                Spherical volume is only computed at points with True indices. 
        
            Returns
            -------
            S : (n,1) float array
                The volumes corresponding to each point.
            G : (n,1) float array
                The  gamma values corresponding to each point.
        &#34;&#34;&#34;
   
        return svi.svi(self.points,self.triangles,r,ID=ID)

    def svipca(self,r):
        &#34;&#34;&#34; Computes SVIPCA

            Parameters
            ----------
            r : (k,1) float array
                List of radii to use.

            Returns
            -------
            S : (n,1) float array
                The volumes corresponding to each point.
            K1 : (n,1) float array
                The first principle curvature for each point.
            K2 : (n,1) float array
                The second principle curvature for each point.
            V1 : (n,3) float array
                The first principal direction for each point. 
            V2 : (n,3) float array
                The second principal direction for each point.
            V3 : (n,3) float array
                The third principal direction for each point.
        &#34;&#34;&#34;

        return svi.svipca(self.points,self.triangles,r)

    def edge_graph_detect(self,**kwargs):
        &#34;&#34;&#34; Detects edges using SVIPCA and principal direction metric.
            
            Parameters
            ----------
            M : amaazetools.trimesh.mesh object
            k1 : float, optional
                A constant on the minimum of the inverse of principal curvatures.
            k2 : float, optional
                A constant on the mean volume.
            VOL : (n,1) float array, optional
                Spherical volume corresponding to each point in the mesh.
            K1 : (n,1) float array, optional
                First principal curvature of each point.
            K2 : (n,1) float array, optional
                Second principal curvature of each point.
            V1 : (n,3) float array, optional
                First principal direction for each point.
            V2 : (n,3) float array, optional
                Second principal direction for each point.
            rvol : float, optional
                Radius to use for svipca.
            rpdir : float, optional
                Radius to use for the principal direction metric.

            Returns
            -------
            Edges : (n,1) boolean array
                A true value corresponds to that index being an edge point.
        &#34;&#34;&#34;
        
        return edge_detection.edge_graph_detect(self,**kwargs)

    def graph_setup(self,n,r,p,seed=None):
        &#34;&#34;&#34; Creates the graph to use for poisson learning.

            Parameters
            ----------
            n : int
                The number of vertices to sample for the graph.
            r : float
                Radius for graph construction.
            p : float
                Weight matrix parameter.
            seed : int, default is None
                Optional seed for random number generator.
        
            Returns
            -------
            poisson_W_matrix : (n,n) scipy.sparse.lil_matrix
                Weight matrix describing similarities of normal vectors.
            poisson_J_matrix : (num_verts,n) scipy.sparse.lil_matrix
                Matrix with indices of nearest neighbors.
            poisson_node_idx : (num_verts,1) int array
                The indices of the closest point in the sample.
        &#34;&#34;&#34;

        rng = (
            np.random.default_rng(seed=seed)
            if seed is not None
            else np.random.default_rng()
        )

        if self.poisson_W_matrix is None or self.poisson_J_matrix is None or self.poisson_node_idx is None:

            v = self.vertex_normals()
            N = self.num_verts()
        
            #Random subsample
            ss_idx = np.matrix(rng.choice(self.points.shape[0],n,replace=False))
            y = np.squeeze(self.points[ss_idx,:])
            w = np.squeeze(v[ss_idx,:])

            xTree = spatial.cKDTree(self.points)
            nn_idx = xTree.query_ball_point(y, r)
            yTree = spatial.cKDTree(y)
            nodes_idx = yTree.query_ball_point(y, r)
        
            bn = np.zeros((n,3))
            J = sparse.lil_matrix((N,n))
            for i in range(n):
                vj = v[nn_idx[i],:]
                normal_diff = w[i] - vj
                weights = np.exp(-8 * np.sum(np.square(normal_diff),1,keepdims=True))
                bn[i] = np.sum(weights*vj,0) / np.sum(weights,0)
            
                #Set ith row of J
                normal_diff = bn[i]- vj
                weights = np.exp(-8 * np.sum(np.square(normal_diff),1))#,keepdims=True))
                J[nn_idx[i],i] = weights
            
            #Normalize rows of J
            RSM = sparse.spdiags((1 / np.sum(J,1)).ravel(),0,N,N)
            J = RSM @ J
        
            #Compute weight matrix W
            W = sparse.lil_matrix((n,n))
            for i in range(n):
                nj = bn[nodes_idx[i]]
                normal_diff = bn[i] - nj
                weights = np.exp(-32 * ((np.sqrt(np.sum(np.square(normal_diff),1)))/2)**p)
                W[i,nodes_idx[i]] = weights
        
            #Find nearest node to each vertex
            nbrs = NearestNeighbors(n_neighbors=1, algorithm=&#39;ball_tree&#39;).fit(y)
            instances, node_idx = nbrs.kneighbors(self.points)

            self.poisson_W_matrix = W
            self.poisson_J_matrix = J
            self.poisson_node_idx = node_idx
        
        return self.poisson_W_matrix, self.poisson_J_matrix, self.poisson_node_idx   

    def poisson_label(self,g,I,n=5000,r=0.5,p=1,s=None,graph_setup=False):
        &#34;&#34;&#34; Performs poisson learning on the mesh.

            Parameters
            ----------
            g : (k,1) int array
                Labels to assign to vertices.
            I : (k,1) int array
                User-selected vertices.
            n : int, default is 5000
                The number of nodes to sample.
            r : float, default is 0.5
                The radius for nearest neighbor search.
            p : float, default is 1.0
                The weight matrix parameter.
            s : default is None
                Weights for fine-tuning Poisson learning.
            graph_setup : boolean, default is False
                Force graph construction if True.
        
            Returns
            -------
            L : (num_verts,1) int array
                Poisson labelling of each point in mesh.
        &#34;&#34;&#34;
    
        if graph_setup or (self.poisson_node_idx is None):
            self.graph_setup(n,r,p)

        I = self.poisson_node_idx[I]
        W = self.poisson_W_matrix
        u = poisson_learning(W,g,I)
        J = self.poisson_J_matrix

        if s is None:
            L = np.argmax(J@u,1)
        else:
            k = np.max(g)+1  #Number of classes, assuming 0,1,2,3,..,k-1 are  used
            L = np.argmax(J@(u*s[:k]),1)
        L = canonical_labels(L)

        self.poisson_labels = L

        return L
    
    #Virtual goniometer
    #Input:
    #   point = location to take measurement (index, or (x,y,z) coordinates)
    #   P = nx3 numpy array of vertices of mesh
    #   T = mx3 numpy array of triangles in mesh
    #Output:
    #   theta = Angle
    #   n1,n2 = Normal vectors between two patches (theta=angle(n1,n2))
    #   C = Clusters (C=1 and C=2 are the two detected clusters, C=0 indicates outside of patch)
    #   E (optional) = array of indices of edge points
    def virtual_goniometer(self,point,r,k=7,SegParam=2,return_edge_points=False,number_edge_points=None):
        &#34;&#34;&#34; Runs a virtual goniometer to measure break angles.

            Parameters
            ----------

            point : (1,3) float array or int
                A mesh vertex, as a coordinate or index.
            r : float
                Radius used to build patch.
            k: int, default is 7
                Number of nearest neighbors to use.
            SegParam : float, default is 2
                Segmentation parameter that encourages splitting patch in half as it increases in size.
            return_edge_points : boolean, default is False
                If True, return edge points in patch.
            number_edge_points : boolean, default is None
                Specifies how many edge points to return.
        
            Returns
            -------
            theta : float
                The break angle.
            n1 : (3,) float array
                Contains the normal vector of one break surface.
            n2 : (3,) float array
                Contains the normal vector of the other surface.
            C : (num_verts,) int array
                Contains the cluster (1 or 2) of each point in the patch; points not in the patch are assigned a 0.
            E : (number_edge_points,1) int array, not returned by default
                List of  edge point indices.
        &#34;&#34;&#34;

        patch_ind = self.geodesic_patch(point,r,k=k)
        patch = self.points[patch_ind,:]
        normals = self.vertex_normals()[patch_ind,:]
        theta,n1,n2,C_local = __virtual_goniometer__(patch,normals,SegParam=SegParam)

        C = np.zeros(self.num_verts())
        C[patch_ind] = C_local


        if return_edge_points:
            E = self.edge_points(C_local,k=k,number=number_edge_points)
            E = patch_ind[E]
            return theta,n1,n2,C,E
        else:
            return theta,n1,n2,C</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="amaazetools.trimesh.mesh.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the bounding box of the mesh.</p>
<h2 id="returns">Returns</h2>
<p>A (3,) float array containing the dimensions of the bounding box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    &#34;&#34;&#34; Computes the bounding box of the mesh.
    
        Returns
        -------
        A (3,) float array containing the dimensions of the bounding box.
    &#34;&#34;&#34;

    if self.centers is None:
        self.face_centers()
    X = self.centers
    n = X.shape[0]
    A = self.tri_areas()

    W = sparse.spdiags(A**2,0,n,n)
    vals,vecs = weighted_pca(X,W)

    vecs = vecs.T
    X = X - np.mean(W*X,axis=0)
    m1 = np.sum(X*vecs[0,:],axis=1)
    l1 = np.max(m1) - np.min(m1)
    m2 = np.sum(X*vecs[1,:],axis=1)
    l2 = np.max(m2) - np.min(m2)
    m3 = np.sum(X*vecs[2,:],axis=1)
    l3 = np.max(m3) - np.min(m3)

    return [l1,l2,l3]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.cplotsurf"><code class="name flex">
<span>def <span class="ident">cplotsurf</span></span>(<span>self, C=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the mesh as a surface using mayavi.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>(num_verts,3) int array</code>, default <code>is -1</code></dt>
<dd>An optional per-vertex labeling scheme to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code><a title="amaazetools.trimesh.mesh" href="#amaazetools.trimesh.mesh">mesh</a> object</code></dt>
<dd>A colored visualization of the mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cplotsurf(self,C=-1):
    &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

        Parameters
        ----------
        C : (num_verts,3) int array, default is -1
            An optional per-vertex labeling scheme to use.
    
        Returns
        -------
        mesh : amaazetools.trimesh.mesh object
            A colored visualization of the mesh.
    &#34;&#34;&#34;

    if C.any == -1: #if no C given
        C = np.ones((len(x),1))
        
    n = len(np.unique(C))
    C = C.astype(int)
    if n&gt;20:
        mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)
    else:
        col = (np.arange(1,n+1)) / n
        colors = col[C-1]
        mesh = mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=colors)
        
    return mesh</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.edge_graph_detect"><code class="name flex">
<span>def <span class="ident">edge_graph_detect</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects edges using SVIPCA and principal direction metric.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code><a title="amaazetools.trimesh.mesh" href="#amaazetools.trimesh.mesh">mesh</a> object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>k1</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>A constant on the minimum of the inverse of principal curvatures.</dd>
<dt><strong><code>k2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>A constant on the mean volume.</dd>
<dt><strong><code>VOL</code></strong> :&ensp;<code>(n,1) float array</code>, optional</dt>
<dd>Spherical volume corresponding to each point in the mesh.</dd>
<dt><strong><code>K1</code></strong> :&ensp;<code>(n,1) float array</code>, optional</dt>
<dd>First principal curvature of each point.</dd>
<dt><strong><code>K2</code></strong> :&ensp;<code>(n,1) float array</code>, optional</dt>
<dd>Second principal curvature of each point.</dd>
<dt><strong><code>V1</code></strong> :&ensp;<code>(n,3) float array</code>, optional</dt>
<dd>First principal direction for each point.</dd>
<dt><strong><code>V2</code></strong> :&ensp;<code>(n,3) float array</code>, optional</dt>
<dd>Second principal direction for each point.</dd>
<dt><strong><code>rvol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius to use for svipca.</dd>
<dt><strong><code>rpdir</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Radius to use for the principal direction metric.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Edges</code></strong> :&ensp;<code>(n,1) boolean array</code></dt>
<dd>A true value corresponds to that index being an edge point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_graph_detect(self,**kwargs):
    &#34;&#34;&#34; Detects edges using SVIPCA and principal direction metric.
        
        Parameters
        ----------
        M : amaazetools.trimesh.mesh object
        k1 : float, optional
            A constant on the minimum of the inverse of principal curvatures.
        k2 : float, optional
            A constant on the mean volume.
        VOL : (n,1) float array, optional
            Spherical volume corresponding to each point in the mesh.
        K1 : (n,1) float array, optional
            First principal curvature of each point.
        K2 : (n,1) float array, optional
            Second principal curvature of each point.
        V1 : (n,3) float array, optional
            First principal direction for each point.
        V2 : (n,3) float array, optional
            Second principal direction for each point.
        rvol : float, optional
            Radius to use for svipca.
        rpdir : float, optional
            Radius to use for the principal direction metric.

        Returns
        -------
        Edges : (n,1) boolean array
            A true value corresponds to that index being an edge point.
    &#34;&#34;&#34;
    
    return edge_detection.edge_graph_detect(self,**kwargs)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.edge_points"><code class="name flex">
<span>def <span class="ident">edge_points</span></span>(<span>self, u, k=7, return_mask=False, number=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the edge points of the mesh.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>Array of labels for each point.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, default <code>is 7</code></dt>
<dd>Number of nearest neighbors to use.</dd>
<dt><strong><code>return_mask</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, return edge_points as a (num,verts,) boolean array.</dd>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code>, default <code>is None</code></dt>
<dd>Max number of edge points to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An int array containing the edge point indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_points(self,u,k=7,return_mask=False,number=None):
    &#34;&#34;&#34; Computes the edge points of the mesh.

        Parameters
        ----------
        u : (num_verts,1) int array
            Array of labels for each point.
        k : int, default is 7
            Number of nearest neighbors to use.
        return_mask : boolean, default is False
            If True, return edge_points as a (num,verts,) boolean array.
        number : int, default is None
            Max number of edge points to return.

        Returns
        -------
        An int array containing the edge point indices.
    &#34;&#34;&#34;

    if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
        self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
    I = self.knn_I[:,:k]
    J = self.knn_J[:,:k]
    D = self.knn_D[:,:k]
    W = gl.weight_matrix(I,J,D,k,f=lambda x : np.ones_like(x),symmetrize=False)
    d = gl.degrees(W)
    mask = d*u != W@u

    #Select a few points spaced out along edge
    if number is not None:
        edge_ind = np.arange(self.num_verts())[mask]
        edge_points = self.points[mask,:]
        num_edge_points = len(edge_points)

        #PCA
        mean = np.mean(edge_points,axis=0)
        cov = (edge_points-mean).T@(edge_points-mean)
        l,v = sparse.linalg.eigs(cov,k=1,which=&#39;LM&#39;)
        proj = (edge_points-mean)@v.real

        #Sort along princpal axis
        sort_ind = np.argsort(proj.flatten())
        dx = (num_edge_points-1)/(number-1)
        spaced_edge_ind = edge_ind[sort_ind[np.arange(0,num_edge_points,dx).astype(int)]]
        mask = np.zeros(self.num_verts(),dtype=bool)
        mask[spaced_edge_ind]=True

    if return_mask:
        return mask.astype(int)
    else: #return indices
        return np.arange(self.num_verts())[mask]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.face_centers"><code class="name flex">
<span>def <span class="ident">face_centers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes coordinates of the center of each triangle (face).</p>
<h2 id="returns">Returns</h2>
<p>A (num_tri,3) float array containing the coordinates of the face centers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_centers(self):
    &#34;&#34;&#34; Computes coordinates of the center of each triangle (face).
    
        Returns
        -------
        A (num_tri,3) float array containing the coordinates of the face centers.
    &#34;&#34;&#34;

    P1 = self.points[self.triangles[:,0],:]
    P2 = self.points[self.triangles[:,1],:]
    P3 = self.points[self.triangles[:,2],:]

    result = (P1 + P2 + P3)/3
    self.centers = result
    return result</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.face_normals"><code class="name flex">
<span>def <span class="ident">face_normals</span></span>(<span>self, normalize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes normal vectors to triangles (faces).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>normalize</code></strong> :&ensp;<code>boolean</code>, default <code>is True</code></dt>
<dd>Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>(num_tri,3) float array</code></dt>
<dd>Array containing the face normal vectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_normals(self,normalize=True):
    &#34;&#34;&#34; Computes normal vectors to triangles (faces).
    
        Parameters
        ----------
        normalize: boolean, default is True
            Whether or not to normalize to unit vectors; if False, vector magnitude is twice the area of the corresponding triangle.
    
        Returns
        -------
        N : (num_tri,3) float array
            Array containing the face normal vectors.
    &#34;&#34;&#34;

    P1 = self.points[self.triangles[:,0],:]
    P2 = self.points[self.triangles[:,1],:]
    P3 = self.points[self.triangles[:,2],:]

    N = np.cross(P2-P1,P3-P1)
    if normalize:
        N = (N.T/np.linalg.norm(N,axis=1)).T
        self.unit_norms = N
        return N
    else:
      self.norms = N
      return N</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.flip_normals"><code class="name flex">
<span>def <span class="ident">flip_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverses the orientation of all normal vectors in the mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip_normals(self):
    &#34;&#34;&#34; Reverses the orientation of all normal vectors in the mesh
    &#34;&#34;&#34;

    self.Triangles = self.Triangles[:,::-1]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.geodesic_patch"><code class="name flex">
<span>def <span class="ident">geodesic_patch</span></span>(<span>self, point, r, k=7, return_mask=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a geodesic patch around a specified point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>int</code> or <code>(1,3) float array</code></dt>
<dd>A mesh vertex.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius used to build patch.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, default <code>is 7</code></dt>
<dd>Number of nearest neighbors to use.</dd>
<dt><strong><code>return_mask</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, return the patch as a (num,verts,) boolean array</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An int array containing the patch point indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodesic_patch(self,point,r,k=7,return_mask=False):
    &#34;&#34;&#34; Computes a geodesic patch around a specified point.

        Parameters
        ----------
        point : int or (1,3) float array
            A mesh vertex.
        r : float
            Radius used to build patch.
        k : int, default is 7
            Number of nearest neighbors to use.
        return_mask : boolean, default is False
            If True, return the patch as a (num,verts,) boolean array

        Returns
        -------
        An int array containing the patch point indices.
    &#34;&#34;&#34;

    if np.any(self.knn_I) is None or np.any(self.knn_J) is None or np.any(self.knn_D) is None:
        self.knn_I,self.knn_J,self.knn_D = gl.knnsearch(self.points,20)
    I = self.knn_I[:,:k]
    J = self.knn_J[:,:k]
    D = self.knn_D[:,:k]
    W = gl.dist_matrix(I,J,D,k)

    point_ind = self.get_index(point)
    dist = gl.cDijkstra(W,np.array([point_ind]),np.array([0]))
    mask = dist &lt; r

    if return_mask:
        return mask.astype(int)
    else: #return indices
        return np.arange(self.num_verts())[mask]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the index of a given point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>int</code> or <code>(1,3) float array</code></dt>
<dd>A vertex in the mesh, specified by either an integer index or its coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The index of the given point as an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index(self,point):
    &#34;&#34;&#34; Computes the index of a given point.

        Parameters
        ----------
        point : int or (1,3) float array
            A vertex in the mesh, specified by either an integer index or its coordinates.

        Returns
        -------
        The index of the given point as an integer.
    &#34;&#34;&#34;

    if type(point) in [np.int,np.int32,np.int64]:
        point_ind=point
    elif type(point) == np.ndarray and len(point)==3:
        point_ind = np.argmin(np.linalg.norm(self.points - point,axis=1))
    elif type(point) in [tuple,list] and len(point)==3:
        point_ind = np.argmin(np.linalg.norm(self.points - np.array(point),axis=1))
    else:
        sys.exit(&#34;&#39;point&#39; must be an integer index, or a length 3 list, tuple, or numpy ndarray (x,y,z)&#34;)
    return point_ind</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.graph_setup"><code class="name flex">
<span>def <span class="ident">graph_setup</span></span>(<span>self, n, r, p, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the graph to use for poisson learning.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of vertices to sample for the graph.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius for graph construction.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Weight matrix parameter.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, default <code>is None</code></dt>
<dd>Optional seed for random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>poisson_W_matrix</code></strong> :&ensp;<code>(n,n) scipy.sparse.lil_matrix</code></dt>
<dd>Weight matrix describing similarities of normal vectors.</dd>
<dt><strong><code>poisson_J_matrix</code></strong> :&ensp;<code>(num_verts,n) scipy.sparse.lil_matrix</code></dt>
<dd>Matrix with indices of nearest neighbors.</dd>
<dt><strong><code>poisson_node_idx</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>The indices of the closest point in the sample.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_setup(self,n,r,p,seed=None):
    &#34;&#34;&#34; Creates the graph to use for poisson learning.

        Parameters
        ----------
        n : int
            The number of vertices to sample for the graph.
        r : float
            Radius for graph construction.
        p : float
            Weight matrix parameter.
        seed : int, default is None
            Optional seed for random number generator.
    
        Returns
        -------
        poisson_W_matrix : (n,n) scipy.sparse.lil_matrix
            Weight matrix describing similarities of normal vectors.
        poisson_J_matrix : (num_verts,n) scipy.sparse.lil_matrix
            Matrix with indices of nearest neighbors.
        poisson_node_idx : (num_verts,1) int array
            The indices of the closest point in the sample.
    &#34;&#34;&#34;

    rng = (
        np.random.default_rng(seed=seed)
        if seed is not None
        else np.random.default_rng()
    )

    if self.poisson_W_matrix is None or self.poisson_J_matrix is None or self.poisson_node_idx is None:

        v = self.vertex_normals()
        N = self.num_verts()
    
        #Random subsample
        ss_idx = np.matrix(rng.choice(self.points.shape[0],n,replace=False))
        y = np.squeeze(self.points[ss_idx,:])
        w = np.squeeze(v[ss_idx,:])

        xTree = spatial.cKDTree(self.points)
        nn_idx = xTree.query_ball_point(y, r)
        yTree = spatial.cKDTree(y)
        nodes_idx = yTree.query_ball_point(y, r)
    
        bn = np.zeros((n,3))
        J = sparse.lil_matrix((N,n))
        for i in range(n):
            vj = v[nn_idx[i],:]
            normal_diff = w[i] - vj
            weights = np.exp(-8 * np.sum(np.square(normal_diff),1,keepdims=True))
            bn[i] = np.sum(weights*vj,0) / np.sum(weights,0)
        
            #Set ith row of J
            normal_diff = bn[i]- vj
            weights = np.exp(-8 * np.sum(np.square(normal_diff),1))#,keepdims=True))
            J[nn_idx[i],i] = weights
        
        #Normalize rows of J
        RSM = sparse.spdiags((1 / np.sum(J,1)).ravel(),0,N,N)
        J = RSM @ J
    
        #Compute weight matrix W
        W = sparse.lil_matrix((n,n))
        for i in range(n):
            nj = bn[nodes_idx[i]]
            normal_diff = bn[i] - nj
            weights = np.exp(-32 * ((np.sqrt(np.sum(np.square(normal_diff),1)))/2)**p)
            W[i,nodes_idx[i]] = weights
    
        #Find nearest node to each vertex
        nbrs = NearestNeighbors(n_neighbors=1, algorithm=&#39;ball_tree&#39;).fit(y)
        instances, node_idx = nbrs.kneighbors(self.points)

        self.poisson_W_matrix = W
        self.poisson_J_matrix = J
        self.poisson_node_idx = node_idx
    
    return self.poisson_W_matrix, self.poisson_J_matrix, self.poisson_node_idx   </code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.num_tri"><code class="name flex">
<span>def <span class="ident">num_tri</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes number of triangles in the mesh.</p>
<h2 id="returns">Returns</h2>
<p>The number of triangles in the mesh as an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_tri(self):
    &#34;&#34;&#34; Computes number of triangles in the mesh.

        Returns
        -------
        The number of triangles in the mesh as an integer.
    &#34;&#34;&#34;

    return self.triangles.shape[0]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.num_verts"><code class="name flex">
<span>def <span class="ident">num_verts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes number of vertices in the mesh.</p>
<h2 id="returns">Returns</h2>
<p>The number of vertices in the mesh as an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_verts(self):
    &#34;&#34;&#34; Computes number of vertices in the mesh.

        Returns
        -------
        The number of vertices in the mesh as an integer.
    &#34;&#34;&#34;

    return self.points.shape[0]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.plotsurf"><code class="name flex">
<span>def <span class="ident">plotsurf</span></span>(<span>self, C=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the mesh as a surface using mayavi.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>(num_verts,3) int array</code>, default <code>is None</code></dt>
<dd>An optional per-vertex labeling scheme to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A visualization of the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotsurf(self,C=None):
    &#34;&#34;&#34; Plots the mesh as a surface using mayavi.

        Parameters
        ----------
        C : (num_verts,3) int array, default is None
            An optional per-vertex labeling scheme to use.
    
        Returns
        -------
        A visualization of the mesh.
    &#34;&#34;&#34;

    if C is None:
        mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles)
    else:
        mlab.triangular_mesh(self.points[:,0],self.points[:,1],self.points[:,2],self.triangles,scalars=C)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.poisson_label"><code class="name flex">
<span>def <span class="ident">poisson_label</span></span>(<span>self, g, I, n=5000, r=0.5, p=1, s=None, graph_setup=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs poisson learning on the mesh.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>g</code></strong> :&ensp;<code>(k,1) int array</code></dt>
<dd>Labels to assign to vertices.</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>(k,1) int array</code></dt>
<dd>User-selected vertices.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, default <code>is 5000</code></dt>
<dd>The number of nodes to sample.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code>, default <code>is 0.5</code></dt>
<dd>The radius for nearest neighbor search.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code>, default <code>is 1.0</code></dt>
<dd>The weight matrix parameter.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>default is None</code></dt>
<dd>Weights for fine-tuning Poisson learning.</dd>
<dt><strong><code>graph_setup</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>Force graph construction if True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>L</code></strong> :&ensp;<code>(num_verts,1) int array</code></dt>
<dd>Poisson labelling of each point in mesh.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poisson_label(self,g,I,n=5000,r=0.5,p=1,s=None,graph_setup=False):
    &#34;&#34;&#34; Performs poisson learning on the mesh.

        Parameters
        ----------
        g : (k,1) int array
            Labels to assign to vertices.
        I : (k,1) int array
            User-selected vertices.
        n : int, default is 5000
            The number of nodes to sample.
        r : float, default is 0.5
            The radius for nearest neighbor search.
        p : float, default is 1.0
            The weight matrix parameter.
        s : default is None
            Weights for fine-tuning Poisson learning.
        graph_setup : boolean, default is False
            Force graph construction if True.
    
        Returns
        -------
        L : (num_verts,1) int array
            Poisson labelling of each point in mesh.
    &#34;&#34;&#34;

    if graph_setup or (self.poisson_node_idx is None):
        self.graph_setup(n,r,p)

    I = self.poisson_node_idx[I]
    W = self.poisson_W_matrix
    u = poisson_learning(W,g,I)
    J = self.poisson_J_matrix

    if s is None:
        L = np.argmax(J@u,1)
    else:
        k = np.max(g)+1  #Number of classes, assuming 0,1,2,3,..,k-1 are  used
        L = np.argmax(J@(u*s[:k]),1)
    L = canonical_labels(L)

    self.poisson_labels = L

    return L</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.surf_area"><code class="name flex">
<span>def <span class="ident">surf_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes surface area of the mesh.</p>
<h2 id="returns">Returns</h2>
<p>The surface area of the entire mesh as a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surf_area(self):
    &#34;&#34;&#34; Computes surface area of the mesh.
    
        Returns
        -------
        The surface area of the entire mesh as a float.
    &#34;&#34;&#34;

    return np.sum(self.tri_areas())</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.svi"><code class="name flex">
<span>def <span class="ident">svi</span></span>(<span>self, r, ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes spherical volume invariant.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>(k,1) float array</code></dt>
<dd>List of radii to use.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>(n,1) boolean array</code>, default <code>is None</code></dt>
<dd>Spherical volume is only computed at points with True indices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The volumes corresponding to each point.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The
gamma values corresponding to each point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def svi(self,r,ID=None):
    &#34;&#34;&#34; Computes spherical volume invariant.
    
        Parameters
        ----------
        r : (k,1) float array
            List of radii to use.
        ID : (n,1) boolean array, default is None
            Spherical volume is only computed at points with True indices. 
    
        Returns
        -------
        S : (n,1) float array
            The volumes corresponding to each point.
        G : (n,1) float array
            The  gamma values corresponding to each point.
    &#34;&#34;&#34;

    return svi.svi(self.points,self.triangles,r,ID=ID)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.svipca"><code class="name flex">
<span>def <span class="ident">svipca</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes SVIPCA</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>(k,1) float array</code></dt>
<dd>List of radii to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The volumes corresponding to each point.</dd>
<dt><strong><code>K1</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The first principle curvature for each point.</dd>
<dt><strong><code>K2</code></strong> :&ensp;<code>(n,1) float array</code></dt>
<dd>The second principle curvature for each point.</dd>
<dt><strong><code>V1</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The first principal direction for each point.</dd>
<dt><strong><code>V2</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The second principal direction for each point.</dd>
<dt><strong><code>V3</code></strong> :&ensp;<code>(n,3) float array</code></dt>
<dd>The third principal direction for each point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def svipca(self,r):
    &#34;&#34;&#34; Computes SVIPCA

        Parameters
        ----------
        r : (k,1) float array
            List of radii to use.

        Returns
        -------
        S : (n,1) float array
            The volumes corresponding to each point.
        K1 : (n,1) float array
            The first principle curvature for each point.
        K2 : (n,1) float array
            The second principle curvature for each point.
        V1 : (n,3) float array
            The first principal direction for each point. 
        V2 : (n,3) float array
            The second principal direction for each point.
        V3 : (n,3) float array
            The third principal direction for each point.
    &#34;&#34;&#34;

    return svi.svipca(self.points,self.triangles,r)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.to_gif"><code class="name flex">
<span>def <span class="ident">to_gif</span></span>(<span>self, fname, color=[], duration=7, fps=20, size=750, histeq=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes rotating gif</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>gif filename</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>(1,3)</code> or <code>(num_verts,1)</code> or <code>(num_verts,2) float array</code>, default <code>is (.7,.7,.7)</code></dt>
<dd>3-tuple 0 to 1 RGB for single color over surface OR array the length of Self.Points for interpolation (1D or 2D - if 2D, uses first column).</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code>, default <code>is 7</code></dt>
<dd>length of gif in seconds</dd>
<dt><strong><code>fps</code></strong> :&ensp;<code>float</code>, default <code>is 20</code></dt>
<dd>frames per second</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code>, default <code>is 750</code></dt>
<dd>size of gif images</dd>
<dt><strong><code>histeq</code></strong> :&ensp;<code>boolean</code>, default <code>is True</code></dt>
<dd>Performs histogram equalization on scalar color array; else should normalize prior to input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_gif(self,fname,color = [],duration=7,fps=20,size=750,histeq = True):
    &#34;&#34;&#34; Writes rotating gif

        Parameters
        ----------
        fname : str
            gif filename
        color : (1,3) or (num_verts,1) or (num_verts,2) float array, default is (.7,.7,.7)
            3-tuple 0 to 1 RGB for single color over surface OR array the length of Self.Points for interpolation (1D or 2D - if 2D, uses first column).
        duration : float, default is 7
            length of gif in seconds
        fps: float, default is 20
            frames per second
        size: float, default is 750
            size of gif images
        histeq : boolean, default is True
            Performs histogram equalization on scalar color array; else should normalize prior to input.
    &#34;&#34;&#34;

    from skimage import exposure
    
    #Make copy of points
    X = self.points.copy()
    
    if np.shape(color)[0] == np.shape(X)[0]: #scalars for plot
        opt = 2
        if histeq:
            color = color - np.amin(color)
            color = 1-exposure.equalize_hist(color/np.max(color),nbins=1000)
            
        if np.shape(np.shape(color))[0]&gt;1: #handle input
            color = color[:,0]
    elif max(np.shape(color)) == 3: #single rgb color
        opt = 1
    else : #not input - default to single color
        color = (0.7,0.7,0.7)
        opt = 1
    
    #PCA
    Mean = np.mean(X,axis=0)
    cov_matrix = (X-Mean).T@(X-Mean)
    Vals, P = np.linalg.eig(cov_matrix)
    idx = Vals.argsort()
    i = idx[2]
    idx[2] = idx[1]
    idx[1] = i
    Vals = Vals[idx]
    P = P[:,idx]
    P[:,2] = np.cross(P[:,0],P[:,1])

    #Rotate fragment
    X = X@P

    #Plot mesh
    f = mlab.figure(bgcolor=(1,1,1),size=(size,size))
    if opt == 1:
        mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,color=color)
    else :
        mlab.triangular_mesh(X[:,0],X[:,1],X[:,2],self.triangles,scalars=color)

    #Function that makes gif animation
    def make_frame(t):
        mlab.view(0,180+t/duration*360)
        GUI().process_events()
        return mlab.screenshot(antialiased=True)

    animation = mpy.VideoClip(make_frame, duration=duration)
    animation.write_gif(fname, fps=fps)
    mlab.close(f)</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.to_ply"><code class="name flex">
<span>def <span class="ident">to_ply</span></span>(<span>self, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the mesh to a .ply file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the .ply file to write the mesh to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_ply(self,fname):
    &#34;&#34;&#34; Writes the mesh to a .ply file.

        Parameters
        ----------
        fname : str
            The name of the .ply file to write the mesh to.
    &#34;&#34;&#34;

    f = open(fname,&#34;w&#34;)

    #Write header
    f.write(&#39;ply\n&#39;)
    f.write(&#39;format binary_little_endian 1.0\n&#39;)
    f.write(&#39;element vertex %u\n&#39;%self.num_verts())
    f.write(&#39;property double x\n&#39;)
    f.write(&#39;property double y\n&#39;)
    f.write(&#39;property double z\n&#39;)
    f.write(&#39;element face %u\n&#39;%self.num_tri())
    f.write(&#39;property list int int vertex_indices\n&#39;)
    f.write(&#39;end_header\n&#39;)
    f.close()

    f = open(fname,&#34;ab&#34;)

    #write vertices
    f.write(self.points.astype(&#39;float64&#39;).tobytes())

    #write faces
    T = np.hstack((np.ones((self.num_tri(),1))*3,self.triangles)).astype(int)
    f.write(T.astype(&#39;int32&#39;).tobytes())

    #close file
    f.close()</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.tri_areas"><code class="name flex">
<span>def <span class="ident">tri_areas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes areas of all triangles in the mesh.</p>
<h2 id="returns">Returns</h2>
<p>A (num_tri,) float array containing the areas of each triangle (face).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_areas(self):
    &#34;&#34;&#34; Computes areas of all triangles in the mesh.
    
        Returns
        -------
        A (num_tri,) float array containing the areas of each triangle (face).
    &#34;&#34;&#34;

    if self.norms is None:
        self.face_normals(False)
    return np.linalg.norm(self.norms,axis=1)/2</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.tri_vert_adj"><code class="name flex">
<span>def <span class="ident">tri_vert_adj</span></span>(<span>self, normalize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a sparse vertex-triangle adjacency matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>normalize</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, each row is divided by the number of adjacent triangles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>F</code></strong> :&ensp;<code>(num_verts,num_tri) boolean array</code></dt>
<dd>Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_vert_adj(self,normalize=False):
    &#34;&#34;&#34; Computes a sparse vertex-triangle adjacency matrix.
   
        Parameters
        ----------
        normalize : boolean, default is False
            If True, each row is divided by the number of adjacent triangles.

        Returns
        -------
        F : (num_verts,num_tri) boolean array
            Adjacency matrix; F[i,j] = 1 if vertex i belongs to triangle j.
    &#34;&#34;&#34;

    num_verts = self.num_verts()
    ind = np.arange(self.num_tri())

    if np.any(self.tri_vert_adj_I) is None or np.any(self.tri_vert_adj_J) is None:
        self.tri_vert_adj_I = np.hstack((self.triangles[:,0],self.triangles[:,1],self.triangles[:,2]))
        self.tri_vert_adj_J = np.hstack((ind,ind,ind))
    I = self.tri_vert_adj_I
    J = self.tri_vert_adj_J
    F = sparse.coo_matrix((np.ones(len(I)), (I,J)),shape=(self.num_verts(),self.num_tri())).tocsr()

    if normalize:
        num_adj_tri = F@np.ones(self.num_tri())
        F = sparse.spdiags(1/num_adj_tri,0,self.num_verts(),self.num_verts())@F

    return F</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.vertex_normals"><code class="name flex">
<span>def <span class="ident">vertex_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes normal vectors to vertices.</p>
<h2 id="returns">Returns</h2>
<p>A (num_verts,3) float array containing the vertex normal vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex_normals(self):
    &#34;&#34;&#34; Computes normal vectors to vertices.
    
        Returns
        -------
        A (num_verts,3) float array containing the vertex normal vectors.
    &#34;&#34;&#34;

    if self.unit_norms is None:
        self.face_normals()
    fn = self.unit_norms
    F = self.tri_vert_adj()
    vn = F@fn
    norms = np.linalg.norm(vn,axis=1)
    norms[norms==0] = 1

    return vn/norms[:,np.newaxis]</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.virtual_goniometer"><code class="name flex">
<span>def <span class="ident">virtual_goniometer</span></span>(<span>self, point, r, k=7, SegParam=2, return_edge_points=False, number_edge_points=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a virtual goniometer to measure break angles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>(1,3) float array</code> or <code>int</code></dt>
<dd>A mesh vertex, as a coordinate or index.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius used to build patch.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code>, default <code>is 7</code></dt>
<dd>Number of nearest neighbors to use.</dd>
<dt><strong><code>SegParam</code></strong> :&ensp;<code>float</code>, default <code>is 2</code></dt>
<dd>Segmentation parameter that encourages splitting patch in half as it increases in size.</dd>
<dt><strong><code>return_edge_points</code></strong> :&ensp;<code>boolean</code>, default <code>is False</code></dt>
<dd>If True, return edge points in patch.</dd>
<dt><strong><code>number_edge_points</code></strong> :&ensp;<code>boolean</code>, default <code>is None</code></dt>
<dd>Specifies how many edge points to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>The break angle.</dd>
<dt><strong><code>n1</code></strong> :&ensp;<code>(3,) float array</code></dt>
<dd>Contains the normal vector of one break surface.</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>(3,) float array</code></dt>
<dd>Contains the normal vector of the other surface.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>(num_verts,) int array</code></dt>
<dd>Contains the cluster (1 or 2) of each point in the patch; points not in the patch are assigned a 0.</dd>
<dt><strong><code>E</code></strong> :&ensp;<code>(number_edge_points,1) int array, not returned by default</code></dt>
<dd>List of
edge point indices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_goniometer(self,point,r,k=7,SegParam=2,return_edge_points=False,number_edge_points=None):
    &#34;&#34;&#34; Runs a virtual goniometer to measure break angles.

        Parameters
        ----------

        point : (1,3) float array or int
            A mesh vertex, as a coordinate or index.
        r : float
            Radius used to build patch.
        k: int, default is 7
            Number of nearest neighbors to use.
        SegParam : float, default is 2
            Segmentation parameter that encourages splitting patch in half as it increases in size.
        return_edge_points : boolean, default is False
            If True, return edge points in patch.
        number_edge_points : boolean, default is None
            Specifies how many edge points to return.
    
        Returns
        -------
        theta : float
            The break angle.
        n1 : (3,) float array
            Contains the normal vector of one break surface.
        n2 : (3,) float array
            Contains the normal vector of the other surface.
        C : (num_verts,) int array
            Contains the cluster (1 or 2) of each point in the patch; points not in the patch are assigned a 0.
        E : (number_edge_points,1) int array, not returned by default
            List of  edge point indices.
    &#34;&#34;&#34;

    patch_ind = self.geodesic_patch(point,r,k=k)
    patch = self.points[patch_ind,:]
    normals = self.vertex_normals()[patch_ind,:]
    theta,n1,n2,C_local = __virtual_goniometer__(patch,normals,SegParam=SegParam)

    C = np.zeros(self.num_verts())
    C[patch_ind] = C_local


    if return_edge_points:
        E = self.edge_points(C_local,k=k,number=number_edge_points)
        E = patch_ind[E]
        return theta,n1,n2,C,E
    else:
        return theta,n1,n2,C</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the volume of the mesh.</p>
<h2 id="returns">Returns</h2>
<p>The volume of the mesh as a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self):
    &#34;&#34;&#34; Computes the volume of the mesh.
    
        Returns
        -------
        The volume of the mesh as a float.
    &#34;&#34;&#34;

    if self.centers is None:
        self.face_centers()
    X = self.centers
    X = X - np.mean(X,axis=0)
    if self.norms is None:
        self.face_normals(False)
    return np.sum(X*self.norms)/6</code></pre>
</details>
</dd>
<dt id="amaazetools.trimesh.mesh.write_color_ply"><code class="name flex">
<span>def <span class="ident">write_color_ply</span></span>(<span>self, color, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the colored mesh to a .ply file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>(num,verts,3) float array</code></dt>
<dd>An array of color data for each point.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the .ply file to write the colored mesh to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_color_ply(self,color,fname):
    &#34;&#34;&#34; Writes the colored mesh to a .ply file.

        Parameters
        ----------
        color : (num,verts,3) float array
            An array of color data for each point.
        fname : str
            The name of the .ply file to write the colored mesh to.
    &#34;&#34;&#34;

    f = open(fname,&#34;w&#34;)

    #Write header
    f.write(&#39;ply\n&#39;)
    f.write(&#39;format binary_little_endian 1.0\n&#39;)
    f.write(&#39;element vertex %u\n&#39;%self.num_verts())
    f.write(&#39;property double x\n&#39;)
    f.write(&#39;property double y\n&#39;)
    f.write(&#39;property double z\n&#39;)
    f.write(&#39;property uchar red\n&#39;)
    f.write(&#39;property uchar green\n&#39;)
    f.write(&#39;property uchar blue\n&#39;)
    f.write(&#39;element face %u\n&#39;%self.num_tri())
    f.write(&#39;property list int int vertex_indices\n&#39;)
    f.write(&#39;end_header\n&#39;)
    f.close()

    f = open(fname,&#34;ab&#34;)

    #write vertices
    for i in range(self.num_verts()):
        f.write(P[i,:].astype(&#39;float64&#39;).tobytes())
        f.write(color[i,:].astype(&#39;uint8&#39;).tobytes())

    #write faces
    T = np.hstack((np.ones((self.num_tri(),1))*3,T)).astype(int)
    f.write(T.astype(&#39;int32&#39;).tobytes())

    #close file
    f.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="amaazetools" href="index.html">amaazetools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="amaazetools.trimesh.canonical_labels" href="#amaazetools.trimesh.canonical_labels">canonical_labels</a></code></li>
<li><code><a title="amaazetools.trimesh.conjgrad" href="#amaazetools.trimesh.conjgrad">conjgrad</a></code></li>
<li><code><a title="amaazetools.trimesh.load_ply" href="#amaazetools.trimesh.load_ply">load_ply</a></code></li>
<li><code><a title="amaazetools.trimesh.pca" href="#amaazetools.trimesh.pca">pca</a></code></li>
<li><code><a title="amaazetools.trimesh.pca_smallest_eig" href="#amaazetools.trimesh.pca_smallest_eig">pca_smallest_eig</a></code></li>
<li><code><a title="amaazetools.trimesh.pca_smallest_eig_powermethod" href="#amaazetools.trimesh.pca_smallest_eig_powermethod">pca_smallest_eig_powermethod</a></code></li>
<li><code><a title="amaazetools.trimesh.poisson_learning" href="#amaazetools.trimesh.poisson_learning">poisson_learning</a></code></li>
<li><code><a title="amaazetools.trimesh.power_method" href="#amaazetools.trimesh.power_method">power_method</a></code></li>
<li><code><a title="amaazetools.trimesh.read_ply" href="#amaazetools.trimesh.read_ply">read_ply</a></code></li>
<li><code><a title="amaazetools.trimesh.weighted_pca" href="#amaazetools.trimesh.weighted_pca">weighted_pca</a></code></li>
<li><code><a title="amaazetools.trimesh.withiness" href="#amaazetools.trimesh.withiness">withiness</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="amaazetools.trimesh.mesh" href="#amaazetools.trimesh.mesh">mesh</a></code></h4>
<ul class="two-column">
<li><code><a title="amaazetools.trimesh.mesh.bbox" href="#amaazetools.trimesh.mesh.bbox">bbox</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.cplotsurf" href="#amaazetools.trimesh.mesh.cplotsurf">cplotsurf</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.edge_graph_detect" href="#amaazetools.trimesh.mesh.edge_graph_detect">edge_graph_detect</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.edge_points" href="#amaazetools.trimesh.mesh.edge_points">edge_points</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.face_centers" href="#amaazetools.trimesh.mesh.face_centers">face_centers</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.face_normals" href="#amaazetools.trimesh.mesh.face_normals">face_normals</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.flip_normals" href="#amaazetools.trimesh.mesh.flip_normals">flip_normals</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.geodesic_patch" href="#amaazetools.trimesh.mesh.geodesic_patch">geodesic_patch</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.get_index" href="#amaazetools.trimesh.mesh.get_index">get_index</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.graph_setup" href="#amaazetools.trimesh.mesh.graph_setup">graph_setup</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.num_tri" href="#amaazetools.trimesh.mesh.num_tri">num_tri</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.num_verts" href="#amaazetools.trimesh.mesh.num_verts">num_verts</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.plotsurf" href="#amaazetools.trimesh.mesh.plotsurf">plotsurf</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.poisson_label" href="#amaazetools.trimesh.mesh.poisson_label">poisson_label</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.surf_area" href="#amaazetools.trimesh.mesh.surf_area">surf_area</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.svi" href="#amaazetools.trimesh.mesh.svi">svi</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.svipca" href="#amaazetools.trimesh.mesh.svipca">svipca</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.to_gif" href="#amaazetools.trimesh.mesh.to_gif">to_gif</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.to_ply" href="#amaazetools.trimesh.mesh.to_ply">to_ply</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.tri_areas" href="#amaazetools.trimesh.mesh.tri_areas">tri_areas</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.tri_vert_adj" href="#amaazetools.trimesh.mesh.tri_vert_adj">tri_vert_adj</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.vertex_normals" href="#amaazetools.trimesh.mesh.vertex_normals">vertex_normals</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.virtual_goniometer" href="#amaazetools.trimesh.mesh.virtual_goniometer">virtual_goniometer</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.volume" href="#amaazetools.trimesh.mesh.volume">volume</a></code></li>
<li><code><a title="amaazetools.trimesh.mesh.write_color_ply" href="#amaazetools.trimesh.mesh.write_color_ply">write_color_ply</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>